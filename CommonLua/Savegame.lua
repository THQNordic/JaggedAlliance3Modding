--[==[

A "savegame" is :
 	- a named piece of data (but note that savenames ARE NOT filenames -- use them only with the Savegame API)
 	- permanently stored in a platform-specific way
	- to "client" code (i.e. user-supplied save/load callbacks) it looks like a folder
	- transparently backed up (optional), so that a failed load will automatically use the backup if available
	- has a metadata table with savename, displayname, timestamp. The game code can supply custom metadata as well

Saving has three usage scenarios:
	- Saved data with autogenerated names and optional "tag" to distinguish between different save types (implicitly never backed up)
	- Saved data with known names (like account.dat) and back up
	- Saved data with known names and no back up
	
	
Loading works both save types. If there is a backup and the "main" save can't be loaded, the backup is transparently loaded.
"Transparently" means that the caller will not know that this has happened.

All save/load/delete/list calls are serialized - you can't make two at the same time, instead they wait for each other
Internally, saving and loading work from/to a preallocated memory buffer (see namespace MemorySavegame on the C-side)
_The save/load callbacks are presented with a folder (which is an in-memory hpk mounted at the SaveGame._MountPoint mountpoint, different every time)
The internal memory buffer can be reallocated by changing config.MemorySavegameSize
	(Beware of fragmentation problems, it's better to increase the default g_nInMemorySaveGame in EngineConfig.cpp instead of tweaking this dynamically)

------------

Public interface:

error, savename = Savegame.WithTag   (tag     , displayname, save_callback, metadata)
error           = Savegame.WithName  (savename, displayname, save_callback, metadata)
error           = Savegame.WithBackup(savename, displayname, save_callback, metadata)

error           = Savegame.Load      (savename, load_callback)
error           = Savegame.LoadWithBackup      (savename, load_callback)
error           = Savegame.Delete    (savename)
error, list     = Savegame.ListForTag(tag) -- tag may be "" meaning no tag, a specific tag, or an array of tags

	list = array of { displayname = "...", savename = "...", timestamp = N, corrupt = true|nil } tables
	
error, count     = Savegame.CountForTag(tag) -- tag may be "" meaning no tag, a specific tag, or an array of tags

Developer tools:

error = Savegame.Export(savename_from, filepath_to)
error = Savegame.Import(filename_from, savename_to)

Callback interface:

error = callback(folder) -- "folder" has a trailing slash


Helper functions (use them from within save/load callbacks)

error, metadata = LoadMetadata(folder)
error = PersistGame(folder)
error = UnpersistGame(folder)

------------

Implementation notes:
- The _Internal* functions do the work
- The _Platform* functions do platform-specific work
- The public interface functions are wrapped (see _Wrap) to disable concurrency

--]==]

sg_print = CreatePrint {
	--"save",
}

function PlayWithoutStorage()
	return false
end

function OnMsg.CanSaveGameQuery(query)
	if GetMap() == "" then
		query.no_map = true
	end
	if GameState.Tutorial and not GetDialog(config.BugReporterXTemplateID) and not Platform.developer then
		query.tutorial = true
	end
	if IsEditorActive() then
		query.editor_active = true
	end
	if PlayWithoutStorage() then
		query.play_without_storage = true
	end
	if StoringSaveGame then
		query.storing = true
	end
	if mapdata and not mapdata.GameLogic then
		query.no_game_logic = true
	end
end

function CanSaveGame(request)
	local query = {}
	Msg("CanSaveGameQuery", query, request)
	if not next(query) then
		return "persist"
	end
	return nil, query
end

StopAutosaveThread = empty_func

-- A namespace. More functions in it are defined below, these are just the platform requisites
Savegame = {
	-- Override these per platform
	_PlatformSaveFromMemory = function(savename, displayname)      assert(false, "Not implemented") return "Not implemented" end,
	_PlatformLoadToMemory   = function(savename)                   assert(false, "Not implemented") return "Not implemented" end,
	_PlatformDelete         = function(savename)                   assert(false, "Not implemented") return "Not implemented" end,
	_PlatformListFileInfo   = function()                           assert(false, "Not implemented") return "Not implemented" end,
	_PlatformListFileNames  = function()                           assert(false, "Not implemented") return "Not implemented" end,
	-- See Savegame._DefaultCopy for a naive implementation, use it if there is no better alternative on the platform
	_PlatformCopy           = function(savename_from, savename_to) assert(false, "Not implemented") return "Not implemented" end,
	-- Called before/after each savegame operation
	_PlatformProlog = function() end,
	_PlatformEpilog = function() end,
	-- supply these two functions to enable loading from mounted disk files; otherwise, savegames are copied to memory first before loading
	_PlatformMountToMemory  = false,
	_PlatformUnmountMemory  = empty_func,
	_CancelLoadToMemory     = empty_func,
	-- path of the currently mounted savegame, false if none
	_MountPoint             = false,
	-- config
	ScreenshotName          = "screenshot.jpg",
	ScreenshotWidth         = 960,
	ScreenshotHeight        = 640,
}

-----------------------------------[ Errors ]-----------------------------------

-- Contexts: savegame | loadgame
-- Errors: "Disk Full", orbis1gb, "File is corrupt"

--------------------------------[ SavegamesList ]-----------------------------------

local AccountStorageSaveDelay = 5000
if FirstLoad then
	SavegamesList = { invalid = true, error = false }
	SavingGame = false
	StoringSaveGame = false
	SavegameRunningThread = false
end

function SavegamesList:Reset()
	self.invalid = true
	self.error = false
	table.iclear(self)
end

function SavegamesList:OnNew(metadata)
	SavegamesList:OnDelete(metadata.savename)
	table.insert(self, 1, metadata)

	if AccountStorage and metadata.savename ~= account_savename then
		AccountStorage.savegameList = AccountStorage.savegameList or {}
		table.insert(AccountStorage.savegameList, 1, metadata)
		SaveAccountStorage(AccountStorageSaveDelay)
	end
end

function SavegamesList:OnDelete(savename) 
	local idx = table.find(self, "savename", savename)
	if idx then
		table.remove(self, idx)
	end

	if AccountStorage and savename ~= account_savename and table.remove_entry(AccountStorage.savegameList or empty_table, "savename", savename) then
		SaveAccountStorage(AccountStorageSaveDelay)
	end
end

function OnMsg.AccountStorageChanged()
	if not AccountStorage or not AccountStorage.savegameList then
		return
	end

	SavegamesList:Reset()
end

function SavegamesList:Refresh()
	if not self.invalid then
		return self.error
	end

	-- Refresh is an internal function called in _InternalListForTag that is already Wrapped
	assert(IsValidThread(SavegameRunningThread) and SavegameRunningThread == CurrentThread())

	self:Reset()

	local useCache = AccountStorage and AccountStorage.savegameList
	local platforminfoError, list = Savegame._PlatformListFileInfo()

	if platforminfoError then
		self.error = platforminfoError;
		return self.error
	end

	local savegames = {}
	local updateAccountStorage = useCache and #list < #AccountStorage.savegameList

	for i=1, #list do
		local savelist_data = false
		local error = false
		local savename = list[i].savename
		local timestamp = list[i].timestamp

		if useCache then
			local idx = table.find(AccountStorage.savegameList, "savename", savename)

			if idx and
			   AccountStorage.savegameList[idx].os_timestamp and
			   AccountStorage.savegameList[idx].os_timestamp >= timestamp then
				savelist_data = AccountStorage.savegameList[idx]
			end
		end
		
		if error or not savelist_data then
			updateAccountStorage = true;

			error = Savegame._InternalLoad(savename, 
				function(folder) 
					local err, metadata = LoadMetadata(folder)
					if err then return err end
					if not metadata then return end

					if metadata.required_lua_revision and metadata.required_lua_revision > LuaRevision then
						return "File is incompatible"
					end

					metadata.savename = savename
					metadata.os_timestamp = timestamp
					metadata.loaded = true
					savelist_data = metadata
				end
			)
		end

		if error or not savelist_data then
			local name = T(857405002607, "Damaged savegame")
			if error == "File is incompatible" then
				name = T(365970916765, "Incompatible savegame")
			end
			savelist_data = { 
				corrupt = error ~= "File is incompatible",
				incompatible = error == "File is incompatible",
				savename = savename, 
				displayname = _InternalTranslate(name), 
				timestamp = os.time()
			}
		end

		savegames[1 + #savegames] = savelist_data
	end

	if Platform.desktop then
		table.sortby_field_descending(savegames, "timestamp")
	else
		table.sortby_field_descending(savegames, "savename")
	end

	if updateAccountStorage then
		AccountStorage.savegameList = savegames
		SaveAccountStorage(AccountStorageSaveDelay)
	end

	for i=1, #savegames do
		self[i] = savegames[i]
	end

	self.invalid = false

	return self.error
end

function SavegamesList:Last()
	return not self.invalid and self[1]
end

function SavegamesList:GenerateFilename(tag)
	if self.invalid then return end
	local timestamp = os.time()
	if tag and tag ~= "" then
		return string.format("%010d.%s.sav", timestamp, tag)
	else
		return string.format("%010d.sav", timestamp)
	end
end

function OnMsg.DeviceChanged()
	SavegamesList:Reset()
end


--------------------------------[ Internals ]-----------------------------------
function Savegame._UniqueName(displayname, tag, params)
	local timestamp = os.time()
	local tag = tag and tag ~= "" and "." .. tag or ""
	if Platform.desktop then
		local displayname = CanonizeSaveGameName(displayname)
		local proposed_name = string.format("%s%s.%s", displayname, tag, "sav")
		local force_overwrite = params and params.force_overwrite
		if not force_overwrite and io.exists(GetPCSaveFolder() .. proposed_name) then
			--a number must be added after the name
			local error, files = AsyncListFiles(GetPCSaveFolder(), string.format("%s(*)%s.%s", displayname, tag, "sav"), "relative")
			local pattern_name = EscapePatternMatchingMagicSymbols(displayname)
			local pattern = pattern_name .. "%((%d+)%)" .. (tag ~= "" and "%" or "") .. tag .. "%.sav$"
			local max_idx = 1
			for i = 1, #files do
				local index = tonumber(string.match(files[i]:lower(), pattern:lower()))
				max_idx = Max(index, max_idx)
			end
			return string.format("%s(%d)%s.%s", displayname, max_idx + 1, tag, "sav"), timestamp
		else
			return proposed_name, timestamp
		end
	else
		return string.format("%010d%s.sav", timestamp, tag), timestamp
	end
end

function Savegame._BackupName(savename) 
	return savename .. ".bak" 
end

function Savegame._Wrap(func)
	return function(...)
		-- wait for other wrapped functions to finish
		while IsValidThread(SavegameRunningThread) do
			WaitMsg(SavegameRunningThread, 111)
		end
		local thread = CurrentThread() or false
		SavegameRunningThread = thread
		Savegame._PlatformProlog()
		local results = pack_params(sprocall(func, ...))
		if not results[1] then
			print("Savegame error:", results[2])
		end
		Savegame._PlatformEpilog()
		assert(SavegameRunningThread == thread)
		if thread then Msg(thread) end
		SavegameRunningThread = false
		if results[1] then
			return unpack_params(results, 2)
		else
			return "Failed"
		end
	end
end

function Savegame._InternalSave(metadata, save_callback, params)
	sg_print("Saving", metadata)
	params = params or {}
	local backup = params.backup
	assert(metadata.savename ~= "")
	assert(not backup or metadata.backupname ~= "")
	assert(metadata.displayname ~= "")
	Savegame.Unmount()
	local error
	if backup then
		local backupname = Savegame._BackupName(metadata.savename)
		error = Savegame._PlatformCopy(metadata.savename, backupname)
		if error then 
			if error ~= "File Not Found" and error ~= "Path Not Found" then
				IgnoreError(error, "SavedataSave/backup")
			end
			error = false
		end
	end
	local mount_point
	error, mount_point = MemorySavegameCreateEmpty()
	if error then return error end
	error = SaveMetadata(mount_point, metadata)
	if error then return error end
	error = save_callback(mount_point, metadata, params)
	
	if not error then
		StoringSaveGame = true
		CreateRealTimeThread(function()
			Msg("StoreSaveGame", true)
			local err = Savegame._PlatformSaveFromMemory(metadata.savename, metadata.displayname)
			Msg("StoreSaveGame", false)
			if err then
				CreateErrorMessageBox(err, "savegame", nil, nil, {savename = T{129666099950, '"<name>"', name = Untranslated(metadata.savename)}, error_code = Untranslated(err)})
			end
			StoringSaveGame = false
			if not err then
				metadata.loaded = true
				SavegamesList:OnNew(metadata)
			end
		end)
	end
	
	return error
end

function Savegame.Unmount()
	if Savegame._MountPoint then
		Savegame._PlatformUnmountMemory()
		Savegame._MountPoint = false
	end
end

function Savegame._InternalLoad(savename, load_callback, params)
	Savegame.Unmount()
	
	local dir = GetPathDir(savename)
	local err, mount_point
	if dir ~= "" and io.exists(savename) then
		err, mount_point = MountToMemory_Desktop(savename)
	else
		err, mount_point = (Savegame._PlatformMountToMemory or Savegame._PlatformLoadToMemory)(savename)
	end
		
	if err then return err end
	err = load_callback(mount_point, params)
	if err then return err end
	Savegame._MountPoint = mount_point
end

function Savegame._InternalLoadWithBackup(savename, load_callback)
	local error_original = Savegame._InternalLoad(savename, load_callback)
	if not error_original then 
		return error_original
	end
	
	-- Delete the damaged original.
	--		This is important, otherwise we would clobber the backup with the damaged original 
	--		when we save a new version.
	if error_original ~= "File Not Found" and error_original ~= "Path Not Found" then
		-- User must be informed before deleting any save data.
		WaitErrorMessage(error_original, "account load", nil, GetLoadingScreenDialog(), { savename = g_AccountStorageSaveName })
		
		local error_delete = Savegame._PlatformDelete(savename)
		if error_delete then 
			IgnoreError(error_delete, "SavedataLoad - delete original") 
		end
	end
	
	-- Try to load from backup
	savename = Savegame._BackupName(savename)
	local error_backup = Savegame._InternalLoad(savename, load_callback)
	if not error_backup then 
		return error_original, error_backup
	end
	
	-- Delete the damaged backup.
	--		This is important, so that we do not spam the user with the same corrupted save.
	if error_backup ~= "File Not Found" and error_backup ~= "Path Not Found" then
		-- User must be informed before deleting any save data.
		WaitErrorMessage(error_backup, "account load backup", nil, GetLoadingScreenDialog(), { savename = g_AccountStorageSaveName })
		
		local error_delete = Savegame._PlatformDelete(savename)
		if error_delete then 
			IgnoreError(error_delete, "SavedataLoad - delete backup") 
		end
	end
	
	return error_original, error_backup
end

function Savegame._InternalDeleteWithBackup(savename)
	Savegame.Unmount()
	-- First delete the backup, otherwise, if we fail, a deleted main + valid backup means the backup may be used
	local error_backup = Savegame._PlatformDelete(Savegame._BackupName(savename))
	if error_backup and error_backup ~= "File Not Found" and error_backup ~= "Path Not Found" then
		return error_backup
	end
	local error = Savegame._PlatformDelete(savename)
	if error then
		return error
	else
		SavegamesList:OnDelete(savename)
	end
end	

function Savegame._InternalListForTag(tag)
	assert(tag)

	local error = SavegamesList:Refresh()

	if error then return error end

	if type(tag)=="string" then
		local list = {}
		for i = 1, #SavegamesList do
			local match = { string.match(SavegamesList[i].savename, "^.*%.(%w+)%.sav$") }
			if (match[1] and tag == match[1]) or (not match[1] and tag == "") then
				table.insert(list, table.copy(SavegamesList[i], "deep"))
			end
		end
		return nil, list
	elseif type(tag)=="table" then
		local list = {}
		for i=1, #tag do
			local error, taglist = Savegame._InternalListForTag(tag[i])
			if error then return error end
			table.iappend(list, taglist)
		end
		-- coming from multiple sources, re-sort
		table.sortby_field_descending( list, "savename" )
		return nil, list
	else
		assert(false, "Unsupported tag type")
	end
end

function Savegame._InternalCountForTag(tag)
	assert(tag)
	local error, files = Savegame._PlatformListFileNames()
	if error then return error end
	if type(tag)=="string" then
		local count = 0
		for i = 1, #(files or "") do
			local match = {string.match(files[i], "^.*%.(%w+)%.sav$")}
			if 	(match[1] and tag == match[1]) or (not match[1] and tag == "") then
				count = count + 1
			end
		end
		return nil, count
	elseif type(tag)=="table" then
		local count = 0
		for i=1, #tag do
			local error, tag_count = Savegame._InternalCountForTag(tag[i])
			if error then return error end
			count = count + tag_count
		end
		return nil, count
	else
		assert(false, "Unsupported tag type")
	end
end

function Savegame._DefaultCopy(savename_from, savename_to)
	local error, mount_point = Savegame._PlatformLoadToMemory(savename_from)
	if error then return error end
	local metadata
	error, metadata = LoadMetadata(mount_point)
	if error then return error end
	return Savegame._PlatformSaveFromMemory(savename_to, metadata.displayname)
end

----------------------------------------------------------------------------------------
--------------------------------[ Platform specific ]-----------------------------------
----------------------------------------------------------------------------------------

if Platform.desktop then
	function GetSavePath(savename)
		local dir = GetPathDir(savename)
		if dir == "" then
			savename = GetPCSaveFolder() .. savename
		end
		return savename
	end
	function Savegame._PlatformSaveFromMemory(savename, displayname)
		return SaveFromMemory_Desktop(GetSavePath(savename), displayname)
	end
	Savegame._PlatformLoadToMemory = function(savename)
		return LoadToMemory_Desktop(GetSavePath(savename))
	end
	Savegame._PlatformDelete = function(savename)
		return AsyncFileDelete(GetSavePath(savename))
	end

	Savegame._PlatformCopy = function(savename_from, savename_to)
		return AsyncCopyFile(GetSavePath(savename_from), GetSavePath(savename_to), "raw")
	end

	Savegame._PlatformMountToMemory = function(savename)
		return MountToMemory_Desktop(GetSavePath(savename))
	end
	Savegame._PlatformUnmountMemory = UnmountMemory_Desktop

	function Savegame._PlatformListFileInfo()
		local error, files = AsyncListFiles(GetPCSaveFolder(), "*.sav", "relative,modified")
		if error then return error end
		local filesInfo = {}
		for i=1,#files do
			filesInfo[1+#filesInfo] = { 
				savename = files[i], 
				timestamp = files["modified"][i]
			}
		end
		return nil, filesInfo
	end
	
	function Savegame._PlatformListFileNames()
		local error, files = AsyncListFiles(GetPCSaveFolder(), "*.sav", "relative")
		if error then return error end
		return nil, files
	end
	
end -- Platform.desktop

--------------------------------[ PS4 ]-----------------------------------

if Platform.playstation then

	function Savegame._PlatformListFileInfo()
		local err, files = AsyncPlayStationSaveDataList()
		if err then return err end
		local filesInfo = {}
		for i=1,#files do
			filesInfo[1+#filesInfo] = { 
				savename = files[i][1],
				timestamp = files[i][3],
			}
		end
		return nil, filesInfo
	end

	function Savegame._PlatformProlog()
		while StoringSaveGame do
			Sleep(1)
		end
	end

	function Savegame._PlatformListFileNames()
		local err, files = AsyncPlayStationSaveDataList()
		if err then return err end
		
		local file_names = {}
		for i=1,#files do
			table.insert(file_names, files[i][1])
		end

		return nil, file_names
	end

	-- Before modifying read: https://p.siedev.net/forums/thread/241339/
	function Savegame._PlatformSaveFromMemory(savename, displayname)
		local err, required_space = AsyncPlayStationSaveRequiredSize()
		if err == "Disk Full" then
			-- handle out-of-storage scenario with a system dialog and retry
			AsyncPlayStationShowFreeSpaceDialog(required_space)
			err, required_space = AsyncPlayStationSaveRequiredSize()
		end
		if err then return err end

		local err, total_size = AsyncPlayStationSaveDataTotalSize()
		if err then return err end

		if total_size + required_space > const.PlayStationMaxSaveDataSizePerUser then
			return "Save Storage Full"
		end

		return AsyncPlayStationSaveFromMemory(savename, displayname, required_space)
	end

	Savegame._PlatformLoadToMemory = AsyncPlayStationLoadToMemory
	Savegame._PlatformDelete = AsyncPlayStationSaveDataDelete
	Savegame._PlatformCopy = Savegame._DefaultCopy
end -- Platform.playstation

--------------------------------[ Xbox ]-----------------------------------

if Platform.xbox then

	function Savegame._PlatformSaveFromMemory(savename, displayname)
		if not Xbox.IsUserSigned() then
			assert("Tring to save game with no active player")
			return "NoUser"
		end
		local err = Xbox.StoreSave(savename, displayname)
		if err then
			Xbox.DeleteSave(savename)
		end
		return err
	end
		
	Savegame._PlatformLoadToMemory = function(savename)
		if not Xbox.IsUserSigned() then
			assert("Trying to load a game with no active player")
			return "NoUser"
		end
		
		return Xbox.MountReadContent(savename)
	end

	Savegame._PlatformDelete = function(savename)	
		if not Xbox.IsUserSigned() then
			assert("Trying to delete savegame with no active player")
			return "NoUser"
		end
		
		return Xbox.DeleteSave(savename)
	end
	
	function Savegame._PlatformListFileInfo()
		if not Xbox.IsUserSigned() then 
			assert("Trying to list savegames with no active player")
			return "NoUser"
		end
		local err, files = Xbox.GetSaveList()
		if err then return err end
		local filesInfo = {}
		for i=1,#files do
			filesInfo[1+#filesInfo] = { 
				savename = files[i][1], 
				timestamp = files[i][3],
			}
		end
		return nil, filesInfo
	end

	function Savegame._PlatformListFileNames()
		if not Xbox.IsUserSigned() then 
			assert("Trying to list savegames with no active player")
			return "NoUser"
		end

		local err, files = Xbox.GetSaveList()
		if err then
			return err
		end	

		local file_names = {}
		for i=1,#files do
			table.insert(file_names, files[i][1])
		end

		return nil, file_names
	end

	Savegame._PlatformCopy = Savegame._DefaultCopy
	
end --Platform.xbox

if Platform.switch then
	function Savegame._PlatformSaveFromMemory(savename, displayname)
		local err = SaveFromMemory_Desktop("saves:/" .. savename, displayname)
		Switch.CommitSaveData()
		return err
	end
	Savegame._PlatformLoadToMemory = function(savename)
		return LoadToMemory_Desktop("saves:/" .. savename)
	end
	Savegame._PlatformDelete = function(savename)
		return AsyncFileDelete("saves:/" .. savename)
	end

	Savegame._PlatformCopy = function(savename_from, savename_to)
		return AsyncCopyFile("saves:/" .. savename_from, "saves:/" .. savename_to, "raw")
	end
	
	function Savegame._PlatformListFileInfo()
		local error, files = AsyncListFiles("saves:/", "*.sav", "relative,modified")
		if error then return error end
		local filesInfo = {}
		for i=1,#files do
			filesInfo[1+#filesInfo] = { 
				savename = files[i], 
				timestamp = files["modified"][i]
			}
		end
		return nil, filesInfo
	end

	function Savegame._PlatformListFileNames()
		local error, files = AsyncListFiles("saves:/", "*.sav", "relative")
		if error then return error end
		return nil, files
	end

end -- Platform.switch

--------------------------------------------------------------------
--------------------------[ Helpers ]-------------------------------
--------------------------------------------------------------------

function AddSystemMetadata(metadata)
	local required_revision = config.SavegameRequiredLuaRevision
	if required_revision == -1 then
		required_revision = LuaRevision
	end
	metadata.lua_revision = LuaRevision
	metadata.assets_revision = AssetsRevision
	metadata.required_lua_revision = required_revision
	metadata.platform = Platform
	metadata.real_time = RealTime()
	FillDlcMetadata(metadata)
end

function SaveMetadata(folder, metadata)
	AddSystemMetadata(metadata)
	return AsyncStringToFile(folder .. "savegame_metadata", TableToLuaCode(metadata))
end
-- returns error, metadata
function LoadMetadata(folder)
	local filename = folder .. "savegame_metadata"
	return FileToLuaValue(filename, {})
end

function UnpersistGame(folder, metadata, params)
	--@@@msg PreLoadGame, metadata - fired before a game is loaded.
	Msg("PreLoadGame", metadata)
	--@@msg LoadGameObjectsUnpersisted, metadata, version - fired when all objects are unpersisted
	local err, version = EngineLoadGame(folder .. "persist", metadata)
	if err then
		if CurrentMapFolder == "" then
			CurrentMapFolder = GetMap() -- make possible to unmount the map
		end
		if CurrentMap == "" then
			CurrentMap = "preloaded map" -- make possible to unmount the map
		end
		DoneMap()
		ChangeMap("")
		return err 
	end
	--@@@msg LoadGame, metadata, version - fired after a game has been loaded.
	Msg("LoadGame", metadata, version, params)
	FixupSavegame(metadata)
	--@@@msg PostLoadGame, metadata, version - fired after LoadGame and with fixups. The loaded game is ready to run (e.g. UI can update).
	Msg("PostLoadGame", metadata, version)
end

function ReportPersistErrors()
	for _, err in ipairs(__error_table__) do
		print("Persist error:", err.error or "unknown")
		print("Persist stack:")
		for _, value in ipairs(err) do
			local str = tostring(value)
			if type(value) == "table" then
				if value.class then
					str = str .. " " .. ObjToStr(value)
				else
					str = str .. " #" .. table.count(value)
				end
			end
			print("   ", str)
		end
		print()
	end
	--[[
	local last_entry = __error_table__[#__error_table__]
	local err_obj = last_entry and last_entry[#last_entry]
	if err_obj then
		local refs = FindReferences(err_obj)
		print("Last entry refs:")
		for _, ref in ipairs(refs) do
			print("   ", ref)
		end
	end
	--]]
end

function PersistGame(folder)
	assert(CanSaveGame() == "persist")
	collectgarbage("collect")
	rawset(_G, "__error_table__", {})
	local filename = folder .. "persist"
	local err = EngineSaveGame(filename)
	ReportPersistErrors()
	assert(#__error_table__ == 0, "Fatal persist errors. CALL A PROGRAMMER!. See __error_table__")
	if not Platform.developer then
		rawset(_G, "__error_table__", false)
	end
	return err
end

---------------------------------------------------------------------------------------
--------------------------------[ Public interface ]-----------------------------------
---------------------------------------------------------------------------------------

Savegame._WrappedSave = Savegame._Wrap(Savegame._InternalSave)

function Savegame.WithTag(tag, displayname, save_callback, metadata, params)
	params = params or {}
	local savename, timestamp = Savegame._UniqueName(displayname, tag, params)
	metadata = metadata or {}
	assert(not metadata.savename and 
	       not metadata.displayname and
		    not metadata.timestamp, "Do not fill reserved metadata fields")
			
	metadata.savename = savename
	metadata.displayname = displayname
	metadata.timestamp = timestamp
	metadata.os_timestamp = timestamp
	metadata.playtime = GetCurrentPlaytime()
	
	params.backup = false
			
	return Savegame._WrappedSave(metadata, save_callback, params), savename
end

function Savegame.WithName(savename, displayname, save_callback, metadata, params)
	params = params or {}
	metadata = metadata or {}
	assert(not metadata.savename and 
	       not metadata.displayname and
		    not metadata.timestamp, "Do not fill reserved metadata fields")
			
	metadata.savename = savename
	metadata.displayname = displayname
	metadata.timestamp = os.time()
	metadata.os_timestamp = os.time()
	metadata.playtime = GetCurrentPlaytime()
	
	params.backup = false
	
	return Savegame._WrappedSave(metadata, save_callback, params)
end

function Savegame.WithBackup(savename, displayname, save_callback, metadata, params)
	params = params or {}
	metadata = metadata or {}
	assert(not metadata.savename and 
	       not metadata.displayname and
		    not metadata.timestamp, "Do not fill reserved metadata fields")
			
	metadata.savename = savename
	metadata.displayname = displayname
	metadata.timestamp = os.time()
	metadata.os_timestamp = os.time()
	metadata.playtime = GetCurrentPlaytime()
	
	params.backup = true
	
	return Savegame._WrappedSave(metadata, save_callback, params)
end

-- error = function(savename, load_callback)
Savegame.LoadWithBackup = Savegame._Wrap(Savegame._InternalLoadWithBackup)

-- error = function(savename, load_callback)
Savegame.Load = Savegame._Wrap(Savegame._InternalLoad)

-- error = function(savename)
Savegame.Delete = Savegame._Wrap(Savegame._InternalDeleteWithBackup)

-- error, list = function(tag)
Savegame.ListForTag = Savegame._Wrap(Savegame._InternalListForTag)

-- error, count = function(tag)
Savegame.CountForTag = Savegame._Wrap(Savegame._InternalCountForTag)

-- function()
Savegame.CancelLoad = Savegame._CancelLoadToMemory

-- on desktop platforms, metadata is always loaded entirely from the savegame, so metadata entries in list are full
-- on consoles, initial load of savegame list results in entries consisting only of savename and displayname, 
-- so this needs to be called when you need the full metadata; it will be loaded if necessary

function GetFullMetadata(metadata, reload)
	if metadata.corrupt then
		return "File is corrupt"
	elseif metadata.incompatible then
		return "File is incompatible"
	elseif metadata.loaded and not reload then
		-- full meta is already loaded
		return
	end
	
	local loaded_meta
	-- keep savename from given metadata, because this is the actual filename
	-- and might differ from the one stored in the savegame if the user has
	-- renamed it manually outside of the game
	local savename = metadata.savename
	local err = Savegame.Load(metadata.savename, function(folder)
		local load_err
		load_err, loaded_meta = LoadMetadata(folder)
		if load_err then return load_err end
		if loaded_meta and loaded_meta.required_lua_revision and loaded_meta.required_lua_revision > LuaRevision then
			return "File is incompatible"
		end
	end)
	
	if err then
		metadata.incompatible = err == "File is incompatible"
		metadata.corrupt =      err ~= "File is incompatible"
		return err
	end
	
	for key, val in pairs(loaded_meta or empty_table) do
		metadata[key] = val
	end
	metadata.savename = savename
	metadata.loaded = true
end

function DeleteGame(name)
	local err = Savegame.Delete(name)
	if not err then
		Msg("SavegameDeleted", name)
	end
	return err
end

function WaitCountSaveGames()
	if PlayWithoutStorage() then
		return 0
	end
	local err, count = Savegame.CountForTag("savegame")
	return not err and count or 0
end

function GameSpecificSaveCallback(folder, metadata, params)
	assert(false, "override this callback in game-specific code")
end

function GameSpecificLoadCallback(folder, metadata, params)
	assert(false, "override this callback in game-specific code")
end

function GameSpecificSaveCallbackBugReport(folder, metadata)
	return PersistGame(folder)
end

function DoSaveGame(display_name, params)
	WaitChangeMapDone()
	WaitSaveGameDone()
	SavingGame = true
	--@@@msg SaveGameStart - fired before the game is saved.
	params = params or {}
	Msg("SaveGameStart", params)
	local metadata = GatherGameMetadata(params)
	local autosave = params.autosave
	if autosave then
		metadata.autosave = autosave
	end
	local err, name
	if params.savename then
		err = Savegame.WithName(params.savename, display_name, GameSpecificSaveCallback, metadata, params)
		name = params.savename
	else
		err, name = Savegame.WithTag("savegame", display_name, GameSpecificSaveCallback, metadata, params)
	end
	SavingGame = false
	if not err and params.save_as_last then
		LocalStorage.last_save = name
		SaveLocalStorage()
	end
	Msg("SaveGameDone", name, autosave, err)
	return err, name, metadata
end

function WaitSaveGameDone()
	if SavingGame then
		WaitMsg("SaveGameDone")
	end
end

function SaveGame(display_name, params)
	params = params or {}
	assert(type(params) == "table")
	local silent = params.silent
	if not silent then
		LoadingScreenOpen("idLoadingScreen", "save savegame")
	end
	
	WaitRenderMode("ui")
	local err, name, meta = DoSaveGame(display_name, params)
	WaitRenderMode("scene")
	
	if not silent then
		LoadingScreenClose("idLoadingScreen", "save savegame")
	end
	return err, name, meta
end

function LoadGame(savename, params)
	local st = GetPreciseTicks()
	params = params or {}
	assert(type(params) == "table")
	LoadingScreenOpen("idLoadingScreen", "load savegame")
	WaitRenderMode("ui", collectgarbage, "collect") -- make sure we clear unused memory so we have enough for to load the game
	local err = Savegame.Load(savename, LoadMetadataCallback, params)
	local loaded_map = GetMap()
	if loaded_map ~= "" then
		WaitRenderMode("scene", collectgarbage, "collect") -- free any leftovers from the load process itself (intermediate data, stale references, etc.)
	else
		collectgarbage("collect") -- free any leftovers from the load process itself (intermediate data, stale references, etc.)
	end
	if params.save_as_last and not err then
		LocalStorage.last_save = savename
		SaveLocalStorage()
	end
	LoadingScreenClose("idLoadingScreen", "load savegame")
	if err then
		print("LoadGame error:", err)
	else
		DebugPrint("Game loaded on map", CurrentMap, "in", GetPreciseTicks() - st, "ms\n")
	end
	return err
end

function SaveGameBugReport(display_name, screenshot)
	return DoSaveGame(display_name)
end

function SaveGameBugReportPStr(display_name)
	WaitChangeMapDone()
	local err, mount_point
	err, mount_point = MemorySavegameCreateEmpty()
	if err then return err end
	-- metadata
	local metadata = GatherBugReportMetadata (display_name)
	err = SaveMetadata(mount_point, metadata)
	if err then return err end
	-- screen shot
	err = GameSpecificSaveCallbackBugReport(mount_point)
	if err then return err end
	--
	return err, MemorySaveGamePStr(0, MemorySaveGameSize())
end

function Savegame.Import(filepath_from, savename_to)
	local err = LoadToMemory_Desktop(filepath_from)
	if err then return err end
	
	local savename, _ = Savegame._UniqueName(savename_to, "savegame")
	return Savegame._PlatformSaveFromMemory(savename, savename_to)
end

function Savegame.Export(savename_from, filepath_to)
	local filedir_to, _, _ = SplitPath(filepath_to)
	local err = AsyncCreatePath(filedir_to)
	if err then return err end

	err = MountPack("exported", filepath_to, "create,compress")
	if err then return err end
	
	err = Savegame.LoadWithBackup(savename_from, 
		function(folder) 
			local err, files = AsyncListFiles(folder, "*", "relative")
			if err then return err end
			for i=1, #files do
				err = AsyncCopyFile(folder..files[i], "exported/"..files[i], "raw")
				if err then return err end
			end
		end)
	UnmountByPath("exported")
	return err
end

function GetSavegameExportPath(savename)
	local console_name = "console"
	local saveDir = "AppData/ExternalSaves/"
	if Platform.ps4 then
		console_name = "ps4"
	elseif Platform.ps5 then
		console_name = "ps5"
		saveDir = "ExportedSaves/"
	elseif Platform.xbox_one_x then
		console_name = "xbox_one_x"
		saveDir = "TmpData/ExportedSaves/"
	elseif Platform.xbox_one then
		console_name = "xbox_one"
		saveDir = "TmpData/ExportedSaves/"
	elseif Platform.xbox_series_x then
		console_name = "xbox_series_x"
		saveDir = "TmpData/ExportedSaves/"
	elseif Platform.xbox_series then
		console_name = "xbox_series"
		saveDir = "TmpData/ExportedSaves/"
	end
	local export_path = string.format(saveDir .. "exp_%s_%s", console_name, savename)
	return savename, export_path
end

--------------------------[ Developer tools ]-------------------------------

if not Platform.cmdline and Platform.pc and Platform.developer then

	function RegisterSavFileHandler()
		local path = ConvertToOSPath(GetExecName())
		if not path or not io.exists(path) then return end
		local name = "hg-" .. const.ProjectName
		local reg = string.format([=[reg add HKCU\Software\Classes\%s\shell\open\command /f /d "cmd /c start \"%s\" /d \"%s\" \"%s\" -save \"%%1\""]=], name, const.ProjectName, GetCWD(), path)
		local err, code = AsyncExec(reg, "", true, true)
		if not err and code == 0 then
			reg = [=[reg add HKCU\Software\Classes\.sav\OpenWithProgids /f /v "]=] .. name .. [=["]=]
			err, code = AsyncExec(reg, "", true, true)
		end
	end

	if FirstLoad and config.RegisterSavFileHandler then
		CreateRealTimeThread(RegisterSavFileHandler)
	end

end -- not Platform.cmdline and Platform.pc and Platform.developer

function SavegameImportHelper()
	CreateRealTimeThread(function()
		local saveDir = "AppData/ExternalSaves/"
		if Platform.xbox then
			saveDir = "TmpData/ExternalSaves/"
		elseif Platform.ps5 then
			saveDir = "ExternalSaves/"
		end
		local err, files = AsyncListFiles(saveDir)
		if err or not next(files) then
			WaitMessage(terminal.desktop,
				T(182714092509, "Fail"),
				Untranslated(string.format("Finding saves to import failed: %s", err or "None")),
				T(1000136, "OK")
			)
			return
		end
		
		local successful_imports = 0
		local failed_imports = 0
		for _, file in ipairs(files) do
			local _, name, ext = SplitPath(file)
			local display_name = "<imported> " .. string.match(name, "(.+)%.")
			local err = Savegame.Import(file, display_name)
			if err then
				failed_imports = failed_imports + 1
				WaitMessage(terminal.desktop,
					Untranslated("Fail"),
					Untranslated(string.format("Importing: %s\nFailed: %s", file, err)),
					Untranslated("OK")
				)
			else
				successful_imports = successful_imports + 1
				if Platform.xbox then Sleep(1000) end
			end
		end
		if successful_imports > 0 then
			SavegamesList:Reset()
		end
		CreateMessageBox(nil,
			Untranslated("Finished"),
			Untranslated(string.format("Imported %d saves, %d failed.", successful_imports, failed_imports)),
			Untranslated("OK")
		)
	end)
end

function SavegameExportHelper(savename)
	local console_name = GetPlatformName()
	local saveBaseDir = (Platform.xbox and "TmpData" or "AppData")
	local export_path = string.format("%s/ExternalSaves/exp_%s_%s", saveBaseDir, console_name, savename)
	local err = Savegame.Export(savename, export_path)
	if not err then
		CreateMessageBox(nil, Untranslated("Success"), Untranslated(string.format("%s exported as %s", savename, export_path)), Untranslated("OK"))
	else
		CreateMessageBox(nil, Untranslated("Error"), Untranslated(string.format("Error while exporting %s: %s", savename, err)), Untranslated("OK"))
	end
end

if Platform.developer then

	if FirstLoad then
		DbgSaveDesync = false
	end

	function DbgToggleSaveSyncTest()
		DbgSaveDesync = not DbgSaveDesync
		if not DbgSaveDesync then
			DbgSyncTestStop()
		end
		print("Save Sync Test:", DbgSaveDesync)
	end

	function OnMsg.LoadGame(meta)
		DeleteThread(DbgSyncTestThread)
		if not DbgSaveDesync or Libs.Network ~= "sync" then
			return
		end
		DbgSyncTestStart(table.hash(meta))
		DbgSyncTestTrack()
	end
	
	function ResaveGame(path, params)
		if not IsRealTimeThread() then
			CreateRealTimeThread(ResaveGame, path, params)
			return
		end
		print("Loading save", path)
		local err = LoadGame(path)
		if err then
			print("Loading error:", err)
			return
		end
		print("Loading success! Saving...")
		params = table.copy(params)
		if params.on_load_callback then
			params.on_load_callback(SavegameMeta)
		end
		params.savename = path
		params.force_overwrite = true
		local err, savepath = SaveGame(SavegameMeta.displayname, params)
		if err then
			print("Saving error:", err)
			return
		end
		print("Saving success!")
	end

end -- Platform.developer
