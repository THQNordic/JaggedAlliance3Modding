-- ========== GENERATED BY SectorOperation Editor DO NOT EDIT MANUALLY! ==========

PlaceObj('SectorOperation', {
	GetSectorSlots = function (self, prof, sector)
		return 3
	end,
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "Mechanic",
			'display_name', T(902193940439, --[[SectorOperation AbandonedBeach_EnablePort display_name]] "Mechanic"),
			'display_name_all_caps', T(703082008006, --[[SectorOperation AbandonedBeach_EnablePort display_name_all_caps]] "MECHANIC"),
			'display_name_plural', T(594576991156, --[[SectorOperation AbandonedBeach_EnablePort display_name_plural]] "Mercs"),
			'display_name_plural_all_caps', T(670767424913, --[[SectorOperation AbandonedBeach_EnablePort display_name_plural_all_caps]] "MECHANICS"),
		}),
	},
	description = T(937371532220, --[[SectorOperation AbandonedBeach_EnablePort description]] 'In exchange for repairing "M.E.R.C.\'s Pride" Captain Pierrot promised to provide transport.'),
	display_name = T(573194379329, --[[SectorOperation AbandonedBeach_EnablePort display_name]] "Launch Boat"),
	group = "Custom Operations",
	icon = "UI/SectorOperations/T_Icon_Activity_QuestActivity",
	id = "AbandonedBeach_EnablePort",
	image = "UI/Messages/Operations/quest_activity",
	log_msg_start = T(874071804761, --[[SectorOperation AbandonedBeach_EnablePort log_msg_start]] "<em><mercs></em> are repairing <em>Pierrot's boat</em> in <SectorName(sector)>"),
	min_requirement_stat = "Mechanical",
	min_requirement_stat_value = 30,
	related_stat = "Mechanical",
	related_stat_2 = "Strength",
	short_name = T(546572639679, --[[SectorOperation AbandonedBeach_EnablePort short_name]] "Special"),
	sub_title = T(360106194278, --[[SectorOperation AbandonedBeach_EnablePort sub_title]] "Put M.E.R.C.'s boat back in the water to enable the Port"),
	target_contribution = 10000,
})

PlaceObj('SectorOperation', {
	GetOperationCost = function (self, merc, profession, idx)
		return  {[1] = {value = self:ResolveValue("PartsCost") , resource = "Parts"}}
	end,
	GetSectorSlots = function (self, prof, sector)
		return 3
	end,
	Parameters = {
		PlaceObj('PresetParamNumber', {
			'Name', "PartsCost",
			'Value', 40,
			'Tag', "<PartsCost>",
		}),
	},
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "Mechanic",
			'display_name', T(902193940439, --[[SectorOperation ArcheologicalRuins_ImproveMine display_name]] "Mechanic"),
			'display_name_all_caps', T(703082008006, --[[SectorOperation ArcheologicalRuins_ImproveMine display_name_all_caps]] "MECHANIC"),
			'display_name_plural', T(594576991156, --[[SectorOperation ArcheologicalRuins_ImproveMine display_name_plural]] "Mercs"),
			'display_name_plural_all_caps', T(670767424913, --[[SectorOperation ArcheologicalRuins_ImproveMine display_name_plural_all_caps]] "MECHANICS"),
		}),
	},
	RequiredResources = {
		"Parts",
	},
	description = T(608096283310, --[[SectorOperation ArcheologicalRuins_ImproveMine description]] "Spend parts and time to improve the mine (can only be done once)"),
	display_name = T(178770675577, --[[SectorOperation ArcheologicalRuins_ImproveMine display_name]] "Improve Mine"),
	group = "Custom Operations",
	icon = "UI/SectorOperations/T_Icon_Activity_QuestActivity",
	id = "ArcheologicalRuins_ImproveMine",
	image = "UI/Messages/Operations/quest_activity",
	min_requirement_stat = "Mechanical",
	min_requirement_stat_value = 50,
	related_stat = "Strength",
	related_stat_2 = "Mechanical",
	short_name = T(495368352107, --[[SectorOperation ArcheologicalRuins_ImproveMine short_name]] "Special"),
	sub_title = T(593346750003, --[[SectorOperation ArcheologicalRuins_ImproveMine sub_title]] "A skilled Mechanic can improve the output of the mine"),
	target_contribution = 10000,
})

PlaceObj('SectorOperation', {
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "Arsonist",
			'display_name', T(198157573130, --[[SectorOperation BaitOutSavannaCamp display_name]] "Arsonist"),
			'display_name_all_caps', T(899529936018, --[[SectorOperation BaitOutSavannaCamp display_name_all_caps]] "ARSONIST"),
			'display_name_plural', T(925894907635, --[[SectorOperation BaitOutSavannaCamp display_name_plural]] "Arsonists"),
			'display_name_plural_all_caps', T(355458771095, --[[SectorOperation BaitOutSavannaCamp display_name_plural_all_caps]] "ARSONISTS"),
		}),
	},
	description = T(751828540901, --[[SectorOperation BaitOutSavannaCamp description]] "If someone was foolish enough to build their camp right in the middle of the savanna during the hot season, wouldn't it be a pity if someone else sets it on fire?"),
	display_name = T(316771484268, --[[SectorOperation BaitOutSavannaCamp display_name]] "Diversion"),
	group = "Custom Operations",
	icon = "UI/SectorOperations/T_Icon_Activity_QuestActivity",
	id = "BaitOutSavannaCamp",
	image = "UI/Messages/Operations/quest_activity",
	min_requirement_stat = "Leadership",
	min_requirement_stat_value = 10,
	related_stat = "Leadership",
	short_name = T(765205633140, --[[SectorOperation BaitOutSavannaCamp short_name]] "Special"),
	sub_title = T(440989749122, --[[SectorOperation BaitOutSavannaCamp sub_title]] "Lure out Legion soldiers from Camp Savane"),
	target_contribution = 2000,
})

PlaceObj('SectorOperation', {
	GetSectorSlots = function (self, prof, sector)
		return 1
	end,
	Parameters = {
		PlaceObj('PresetParamNumber', {
			'Name', "HealPerTickBase",
			'Value', 12,
			'Tag', "<HealPerTickBase>",
		}),
	},
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "Lure",
			'display_name', T(606685561530, --[[SectorOperation BusGang_Wait1 display_name]] "Waiting merc"),
			'display_name_all_caps', T(851940355563, --[[SectorOperation BusGang_Wait1 display_name_all_caps]] "WAITING MERC"),
			'display_name_plural', T(839048560862, --[[SectorOperation BusGang_Wait1 display_name_plural]] "Waiting mercs"),
			'display_name_plural_all_caps', T(345347898229, --[[SectorOperation BusGang_Wait1 display_name_plural_all_caps]] "WAITING MERCS"),
		}),
	},
	bonus_perks = {
		PlaceObj('SectorOperationBonusPerk', {
			'perk', "Optimist",
			'bonus', 50,
		}),
	},
	description = T(993718235395, --[[SectorOperation BusGang_Wait1 description]] 'Have some rest while waiting for the "Bus Gang" to come and kill you for staying at "their" bus stop'),
	display_name = T(821011339010, --[[SectorOperation BusGang_Wait1 display_name]] "Wait for Bus Gang"),
	group = "Custom Operations",
	icon = "UI/SectorOperations/T_Icon_Activity_QuestActivity",
	id = "BusGang_Wait1",
	image = "UI/Messages/Operations/quest_activity",
	log_msg_start = T(961591013952, --[[SectorOperation BusGang_Wait1 log_msg_start]] '<em><mercs></em> started <em>waiting for the "Bus Gang"</em> in <SectorName(sector)>'),
	short_name = T(141516117723, --[[SectorOperation BusGang_Wait1 short_name]] "Special"),
	target_contribution = 3000,
})

PlaceObj('SectorOperation', {
	GetSectorSlots = function (self, prof, sector)
		return 1
	end,
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "Lure",
			'display_name', T(606685561530, --[[SectorOperation BusGang_Wait2 display_name]] "Waiting merc"),
			'display_name_all_caps', T(851940355563, --[[SectorOperation BusGang_Wait2 display_name_all_caps]] "WAITING MERC"),
			'display_name_plural', T(839048560862, --[[SectorOperation BusGang_Wait2 display_name_plural]] "Waiting mercs"),
			'display_name_plural_all_caps', T(345347898229, --[[SectorOperation BusGang_Wait2 display_name_plural_all_caps]] "WAITING MERCS"),
		}),
	},
	bonus_perks = {
		PlaceObj('SectorOperationBonusPerk', {
			'perk', "Optimist",
			'bonus', 50,
		}),
	},
	description = T(596590918514, --[[SectorOperation BusGang_Wait2 description]] 'Wait a bit more for the "Bus Gang" to come and kill you for staying at "their" bus stop'),
	display_name = T(537376203318, --[[SectorOperation BusGang_Wait2 display_name]] "Wait again"),
	group = "Custom Operations",
	icon = "UI/SectorOperations/T_Icon_Activity_QuestActivity",
	id = "BusGang_Wait2",
	image = "UI/Messages/Operations/quest_activity",
	log_msg_start = T(732898500173, --[[SectorOperation BusGang_Wait2 log_msg_start]] '<em><mercs></em> started <em>waiting for the "Bus Gang"</em> in <SectorName(sector)>'),
	short_name = T(578093568238, --[[SectorOperation BusGang_Wait2 short_name]] "Special"),
	target_contribution = 2000,
})

PlaceObj('SectorOperation', {
	GetSectorSlots = function (self, prof, sector)
		return 4
	end,
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "Gravedigger",
			'display_name', T(624783582098, --[[SectorOperation CursedForest_BuryInfected display_name]] "Gravedigger"),
			'display_name_all_caps', T(326472192249, --[[SectorOperation CursedForest_BuryInfected display_name_all_caps]] "GRAVEDIGGER"),
			'display_name_plural', T(404819755353, --[[SectorOperation CursedForest_BuryInfected display_name_plural]] "Gravediggers"),
			'display_name_plural_all_caps', T(978215578205, --[[SectorOperation CursedForest_BuryInfected display_name_plural_all_caps]] "GRAVEDIGGERS"),
		}),
	},
	bonus_perks = {
		PlaceObj('SectorOperationBonusPerk', {
			'perk', "Spiritual",
			'bonus', 50,
		}),
	},
	description = T(907346238754, --[[SectorOperation CursedForest_BuryInfected description]] "Gather the corpses from the shipwreck and finish the job of burying them."),
	display_name = T(846413973781, --[[SectorOperation CursedForest_BuryInfected display_name]] "Bury the dead"),
	group = "Custom Operations",
	icon = "UI/SectorOperations/T_Icon_Activity_QuestActivity",
	id = "CursedForest_BuryInfected",
	image = "UI/Messages/Operations/quest_activity",
	log_msg_start = T(822822253790, --[[SectorOperation CursedForest_BuryInfected log_msg_start]] "<em><mercs></em> are burying the <em>dead bodies</em> in <SectorName(sector)>"),
	related_stat = "Strength",
	related_stat_2 = "Health",
	short_name = T(364084315489, --[[SectorOperation CursedForest_BuryInfected short_name]] "Special"),
	sub_title = T(408698738044, --[[SectorOperation CursedForest_BuryInfected sub_title]] "Bury the dead before the disease spreads"),
	target_contribution = 10000,
})

PlaceObj('SectorOperation', {
	GetSectorSlots = function (self, prof, sector)
		return 4
	end,
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "Gravedigger",
			'display_name', T(629692582388, --[[SectorOperation CursedForest_LoadBoat display_name]] "Gravedigger"),
			'display_name_all_caps', T(951926180005, --[[SectorOperation CursedForest_LoadBoat display_name_all_caps]] "GRAVEDIGGER"),
			'display_name_plural', T(475210030580, --[[SectorOperation CursedForest_LoadBoat display_name_plural]] "Gravediggers"),
			'display_name_plural_all_caps', T(569052864899, --[[SectorOperation CursedForest_LoadBoat display_name_plural_all_caps]] "GRAVEDIGGERS"),
		}),
	},
	bonus_perks = {
		PlaceObj('SectorOperationBonusPerk', {
			'perk', "Spiritual",
			'bonus', 50,
		}),
	},
	description = T(325057367990, --[[SectorOperation CursedForest_LoadBoat description]] "Gather the corpses floating on the river and load them on the mysterious boat."),
	display_name = T(299488498067, --[[SectorOperation CursedForest_LoadBoat display_name]] "Load the boat"),
	group = "Custom Operations",
	icon = "UI/SectorOperations/T_Icon_Activity_QuestActivity",
	id = "CursedForest_LoadBoat",
	image = "UI/Messages/Operations/quest_activity",
	log_msg_start = T(250409632668, --[[SectorOperation CursedForest_LoadBoat log_msg_start]] "<em><mercs></em> are loading the <em>boat of the dead</em> in <SectorName(sector)>"),
	related_stat = "Health",
	related_stat_2 = "Wisdom",
	short_name = T(559882714600, --[[SectorOperation CursedForest_LoadBoat short_name]] "Special"),
	sub_title = T(840917924463, --[[SectorOperation CursedForest_LoadBoat sub_title]] "Load the floating corpses on the boat"),
	target_contribution = 10000,
})

PlaceObj('SectorOperation', {
	CustomRepeat = true,
	GetSectorSlots = function (self, prof, sector)
		return 4
	end,
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "Junk Harvester",
			'display_name', T(329794326357, --[[SectorOperation HarvestJunk display_name]] "Junk Harvester"),
			'display_name_all_caps', T(773891734225, --[[SectorOperation HarvestJunk display_name_all_caps]] "JUNK HARVESTER"),
			'display_name_plural', T(912522887391, --[[SectorOperation HarvestJunk display_name_plural]] "Junk Harvesters"),
			'display_name_plural_all_caps', T(900123299595, --[[SectorOperation HarvestJunk display_name_plural_all_caps]] "JUNK HARVESTERS"),
		}),
	},
	description = T(574126932423, --[[SectorOperation HarvestJunk description]] "Send mercs to gather useful Parts at the Dump"),
	display_name = T(435928835348, --[[SectorOperation HarvestJunk display_name]] "Harvest Junk"),
	group = "Custom Operations",
	icon = "UI/SectorOperations/T_Icon_Activity_QuestActivity",
	id = "HarvestJunk",
	image = "UI/Messages/Operations/quest_activity",
	log_msg_start = T(413667504997, --[[SectorOperation HarvestJunk log_msg_start]] "<em><mercs></em> are <em>gathering junk</em> at <SectorName(sector)>"),
	related_stat = "Mechanical",
	related_stat_2 = "Health",
	short_name = T(663807442979, --[[SectorOperation HarvestJunk short_name]] "Special"),
	sub_title = T(385296517918, --[[SectorOperation HarvestJunk sub_title]] "The friends of la Baronne have access to the riches of the Dump"),
	target_contribution = 12000,
})

PlaceObj('SectorOperation', {
	BoostProgress = function (self, perc, sector)
		return 0
	end,
	CheckCompleted = function (self, merc, sector)
		if #GetOperationProfessionals(sector.Id, self.id) == 0 then
			self:Complete(sector)
		end
	end,
	CustomRepeat = true,
	FilterAvailable = function (self, merc, profession)
		return merc:HasStatusEffect("Wounded")
	end,
	GetOperationCost = function (self, merc, profession, idx)
		local cost = PatientGetWoundedStacks(merc) * self:ResolveValue("MoneyPerWound")
		if HasPerk(merc, "Negotiator") then
			local discount = CharacterEffectDefs.Negotiator:ResolveValue("discountPercent")
			cost = cost - MulDivRound(cost, discount, 100)
		end
		local sector = merc:GetSector()
		local loyalty = GetCityLoyalty(sector.City)
		local diff = cost * self:ResolveValue("min_loyalty_cost_mul") - cost
		cost = cost + MulDivRound(100 - loyalty,  diff, 100) -- scale by loyalty
		return {[1] = {value = cost, resource = "Money"}}
	end,
	GetSectorSlots = function (self, prof, sector)
		return 2
	end,
	HasOperation = function (self, sector)
		if self.Custom then
			return sector.custom_operations and sector.custom_operations[self.id] and
				sector.custom_operations[self.id].status == "enabled"
		end
		return true
	end,
	IsEnabled = function (self, sector)
		return true
	end,
	OnRemoveOperation = function (self, merc)
		if IsPatient(merc) then
			merc.wounds_being_treated = 0
		end	
	end,
	OnSetOperation = function (self, merc, arg)
		if IsPatient(merc) then
			merc.wounds_being_treated = arg or PatientGetWoundedStacks(merc)
		end
	end,
	Parameters = {
		PlaceObj('PresetParamNumber', {
			'Name', "HealPerTickBase",
			'Value', 20,
			'Tag', "<HealPerTickBase>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "HealWoundThreshold",
			'Value', 1000,
			'Tag', "<HealWoundThreshold>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "min_loyalty_cost_mul",
			'Value', 3,
			'Tag', "<min_loyalty_cost_mul>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "MoneyPerWound",
			'Value', 50,
			'Tag', "<MoneyPerWound>",
		}),
	},
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "Patient",
			'display_name', T(209941094747, --[[SectorOperation HospitalTreatmentCustom display_name]] "Patient"),
			'description', T(919103873098, --[[SectorOperation HospitalTreatmentCustom description]] "All wounds will be gradually removed from the Patient."),
			'display_name_all_caps', T(835869811030, --[[SectorOperation HospitalTreatmentCustom display_name_all_caps]] "PATIENT"),
			'display_name_plural', T(232149671912, --[[SectorOperation HospitalTreatmentCustom display_name_plural]] "Patients"),
			'display_name_plural_all_caps', T(168851163196, --[[SectorOperation HospitalTreatmentCustom display_name_plural_all_caps]] "PATIENTS"),
		}),
	},
	ProgressCompleteThreshold = function (self, merc, sector, prediction)
		if not merc or prediction~="Patient" then
			local slowest = 0
			for _, merc in ipairs(GetOperationProfessionals(sector.Id, self.id)) do
				slowest = Max(slowest, PatientGetWoundsBeingTreated(merc) * self:ResolveValue("HealWoundThreshold"))
			end
			return slowest
		end
		return PatientGetWoundsBeingTreated(merc) * self:ResolveValue("HealWoundThreshold")
	end,
	ProgressCurrent = function (self, merc, sector, prediction)
		if not merc or prediction~="Patient"  then
			local slowest = 0
			for _, merc in ipairs(GetOperationProfessionals(sector.Id, self.id)) do
				slowest = Max(slowest, merc.heal_wound_progress)
			end
			return slowest
		end
		return merc and merc.heal_wound_progress or 0
	end,
	ProgressPerTick = function (self, merc)
		return self:ResolveValue("HealPerTickBase")
	end,
	RequiredResources = {
		"Money",
	},
	SectorOperationStats = function (self, sector)
		return false, false
	end,
	Tick = function (self, merc)
		UnitHealPerTick(merc, self:ProgressPerTick(merc),self:ResolveValue("HealWoundThreshold"))
		if IsPatientReady(merc) then
			merc:SetCurrentOperation("Idle")
			CityModifyLoyalty("RefugeeCamp", 5)
		end
		self:CheckCompleted(merc, merc:GetSector())
	end,
	description = T(722455793925, --[[SectorOperation HospitalTreatmentCustom description]] "Medical treatment by <em>Sangoma</em>. High <em>Loyalty</em> in this sector decreases the cost of health care."),
	display_name = T(428200889177, --[[SectorOperation HospitalTreatmentCustom display_name]] "Shaman Treatment"),
	group = "Custom Operations",
	icon = "UI/SectorOperations/T_Icon_Activity_Healing_Doctor",
	id = "HospitalTreatmentCustom",
	image = "UI/Messages/Operations/shaman_treatment",
	log_msg_start = T(306665695446, --[[SectorOperation HospitalTreatmentCustom log_msg_start]] "<em><mercs></em> are being <em>healed by Sangoma</em> in <SectorName(sector)>"),
	operation_type = {
		Healing = true,
	},
	short_name = T(639901626549, --[[SectorOperation HospitalTreatmentCustom short_name]] "Special"),
	sub_title = T(429966872351, --[[SectorOperation HospitalTreatmentCustom sub_title]] "Sangoma would heal anyone who comes to him for help"),
})

PlaceObj('SectorOperation', {
	BoostProgress = function (self, perc, sector)
		return 0
	end,
	CheckCompleted = function (self, merc, sector)
		if #GetOperationProfessionals(sector.Id, self.id) == 0 then
			self:Complete(sector)
		end
	end,
	CustomRepeat = true,
	FilterAvailable = function (self, merc, profession)
		return merc:HasStatusEffect("Wounded")
	end,
	GetOperationCost = function (self, merc, profession, idx)
		local cost = PatientGetWoundedStacks(merc) * self:ResolveValue("MoneyPerWound")
		if HasPerk(merc, "Negotiator") then
			local discount = CharacterEffectDefs.Negotiator:ResolveValue("discountPercent")
			cost = cost - MulDivRound(cost, discount, 100)
		end
		local sector = merc:GetSector()
		local loyalty = GetCityLoyalty(sector.City)
		local diff = cost * self:ResolveValue("min_loyalty_cost_mul") - cost
		cost = cost + MulDivRound(100 - loyalty,  diff, 100) -- scale by loyalty
		return {[1] = {value = cost, resource = "Money"}}
	end,
	GetSectorSlots = function (self, prof, sector)
		return 2
	end,
	HasOperation = function (self, sector)
		if self.Custom then
			return sector.custom_operations and sector.custom_operations[self.id] and
				sector.custom_operations[self.id].status == "enabled"
		end
		return true
	end,
	IsEnabled = function (self, sector)
		return true
	end,
	OnRemoveOperation = function (self, merc)
		if IsPatient(merc) then
			merc.wounds_being_treated = 0
		end	
	end,
	OnSetOperation = function (self, merc, arg)
		if IsPatient(merc) then
			merc.wounds_being_treated = arg or PatientGetWoundedStacks(merc)
		end
	end,
	Parameters = {
		PlaceObj('PresetParamNumber', {
			'Name', "HealPerTickBase",
			'Value', 30,
			'Tag', "<HealPerTickBase>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "HealWoundThreshold",
			'Value', 1000,
			'Tag', "<HealWoundThreshold>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "min_loyalty_cost_mul",
			'Value', 3,
			'Tag', "<min_loyalty_cost_mul>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "MoneyPerWound",
			'Value', 150,
			'Tag', "<MoneyPerWound>",
		}),
	},
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "Patient",
			'display_name', T(149214043742, --[[SectorOperation HospitalTreatmentWitch display_name]] "Patient"),
			'description', T(458378955262, --[[SectorOperation HospitalTreatmentWitch description]] "All wounds will be gradually removed from the Patient."),
			'display_name_all_caps', T(548563806213, --[[SectorOperation HospitalTreatmentWitch display_name_all_caps]] "PATIENT"),
			'display_name_plural', T(369205610978, --[[SectorOperation HospitalTreatmentWitch display_name_plural]] "Patients"),
			'display_name_plural_all_caps', T(462091819802, --[[SectorOperation HospitalTreatmentWitch display_name_plural_all_caps]] "PATIENTS"),
		}),
	},
	ProgressCompleteThreshold = function (self, merc, sector, prediction)
		if not merc or prediction~="Patient" then
			local slowest = 0
			for _, merc in ipairs(GetOperationProfessionals(sector.Id, self.id)) do
				slowest = Max(slowest, PatientGetWoundsBeingTreated(merc) * self:ResolveValue("HealWoundThreshold"))
			end
			return slowest
		end
		return PatientGetWoundsBeingTreated(merc) * self:ResolveValue("HealWoundThreshold")
	end,
	ProgressCurrent = function (self, merc, sector, prediction)
		if not merc or prediction~="Patient"  then
			local slowest = 0
			for _, merc in ipairs(GetOperationProfessionals(sector.Id, self.id)) do
				slowest = Max(slowest, merc.heal_wound_progress)
			end
			return slowest
		end
		return merc and merc.heal_wound_progress or 0
	end,
	ProgressPerTick = function (self, merc)
		return self:ResolveValue("HealPerTickBase")
	end,
	RequiredResources = {
		"Money",
	},
	SectorOperationStats = function (self, sector)
		return false, false
	end,
	Tick = function (self, merc)
		UnitHealPerTick(merc, self:ProgressPerTick(merc),self:ResolveValue("HealWoundThreshold"))
		if IsPatientReady(merc) then
			merc:SetCurrentOperation("Idle")
		end
		self:CheckCompleted(merc, merc:GetSector())
	end,
	description = T(125551190940, --[[SectorOperation HospitalTreatmentWitch description]] "Medical treatment by the <em>Witch</em>. High <em>Loyalty</em> in this sector decreases the cost of health care."),
	display_name = T(864337407310, --[[SectorOperation HospitalTreatmentWitch display_name]] "Witch Treatment"),
	group = "Custom Operations",
	icon = "UI/SectorOperations/T_Icon_Activity_Healing_Doctor",
	id = "HospitalTreatmentWitch",
	image = "UI/Messages/Operations/shaman_treatment",
	log_msg_start = T(850228730432, --[[SectorOperation HospitalTreatmentWitch log_msg_start]] "<em><mercs></em> are being <em>healed by the Witch</em> in <SectorName(sector)>"),
	operation_type = {
		Healing = true,
	},
	short_name = T(244430903452, --[[SectorOperation HospitalTreatmentWitch short_name]] "Special"),
	sub_title = T(167625248691, --[[SectorOperation HospitalTreatmentWitch sub_title]] "The Witch can heal the body and guide the soul"),
})

PlaceObj('SectorOperation', {
	GetSectorSlots = function (self, prof, sector)
		return 2
	end,
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "ProspectingOverseer",
			'display_name', T(635676277682, --[[SectorOperation OldDiamond_Prospecting display_name]] "Prospecting Overseer"),
			'display_name_all_caps', T(571639355819, --[[SectorOperation OldDiamond_Prospecting display_name_all_caps]] "PROSPECTING OVERSEER"),
			'display_name_plural', T(945656629179, --[[SectorOperation OldDiamond_Prospecting display_name_plural]] "Prospecting Overseers"),
			'display_name_plural_all_caps', T(987163205450, --[[SectorOperation OldDiamond_Prospecting display_name_plural_all_caps]] "PROSPECTING OVERSEERS"),
		}),
	},
	description = T(582133365714, --[[SectorOperation OldDiamond_Prospecting description]] "Send mercs to oversee mining operations."),
	display_name = T(796711771083, --[[SectorOperation OldDiamond_Prospecting display_name]] "Prospect for diamonds"),
	group = "Custom Operations",
	icon = "UI/SectorOperations/T_Icon_Activity_QuestActivity",
	id = "OldDiamond_Prospecting",
	image = "UI/Messages/Operations/quest_activity",
	log_msg_start = T(852123105116, --[[SectorOperation OldDiamond_Prospecting log_msg_start]] "<em><mercs></em> are overseeing <em>diamond deposit prospecting</em> at <SectorName(sector)>"),
	min_requirement_stat = "Mechanical",
	min_requirement_stat_value = 10,
	related_stat = "Leadership",
	related_stat_2 = "Mechanical",
	short_name = T(163985094567, --[[SectorOperation OldDiamond_Prospecting short_name]] "Special"),
	sub_title = T(109439822175, --[[SectorOperation OldDiamond_Prospecting sub_title]] "Guide mining operations for locating a diamond deposit under the administrative building of Old Diamond"),
	target_contribution = 10000,
})

PlaceObj('SectorOperation', {
	GetSectorSlots = function (self, prof, sector)
		return 1
	end,
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "Medic",
			'display_name', T(998570921992, --[[SectorOperation RefugeeCamp_HelpShaman display_name]] "Medic"),
			'display_name_all_caps', T(957266924967, --[[SectorOperation RefugeeCamp_HelpShaman display_name_all_caps]] "MEDIC"),
			'display_name_plural', T(728106329100, --[[SectorOperation RefugeeCamp_HelpShaman display_name_plural]] "Medics"),
			'display_name_plural_all_caps', T(502268650425, --[[SectorOperation RefugeeCamp_HelpShaman display_name_plural_all_caps]] "MEDICS"),
		}),
	},
	RequiredResources = {
		"Meds",
	},
	description = T(899924412018, --[[SectorOperation RefugeeCamp_HelpShaman description]] "Cure the diseased and make sure that the disease doesn't spread in the Refugee Camp."),
	display_name = T(867676898003, --[[SectorOperation RefugeeCamp_HelpShaman display_name]] "Cure the diseased"),
	group = "Custom Operations",
	icon = "UI/SectorOperations/T_Icon_Activity_QuestActivity",
	id = "RefugeeCamp_HelpShaman",
	image = "UI/Messages/Operations/quest_activity",
	log_msg_start = T(457005677615, --[[SectorOperation RefugeeCamp_HelpShaman log_msg_start]] "<em><mercs></em> are helping <em>Sangoma</em> in <SectorName(sector)>"),
	min_requirement_stat = "Medical",
	min_requirement_stat_value = 60,
	related_stat = "Medical",
	short_name = T(404883880324, --[[SectorOperation RefugeeCamp_HelpShaman short_name]] "Special"),
	sub_title = T(841059805527, --[[SectorOperation RefugeeCamp_HelpShaman sub_title]] "Take care of the diseased family of <em>Sangoma</em>"),
	target_contribution = 10000,
})

PlaceObj('SectorOperation', {
	CustomRepeat = true,
	FilterAvailable = function (self, merc, profession)
		if merc.session_id ~= "Larry" then return false end
		
		return not self.min_requirement_stat or merc[self.min_requirement_stat] >= self.min_requirement_stat_value
	end,
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "RehabPatient",
			'display_name', T(327130871804, --[[SectorOperation AddictionTreatment display_name]] "Rehab Patient"),
			'description', T(465020561082, --[[SectorOperation AddictionTreatment description]] "A merc undergoing rehabilitation."),
			'display_name_all_caps', T(773154275797, --[[SectorOperation AddictionTreatment display_name_all_caps]] "REHAB PATIENT"),
			'display_name_plural', T(914110997422, --[[SectorOperation AddictionTreatment display_name_plural]] "Patients"),
			'display_name_plural_all_caps', T(362090545388, --[[SectorOperation AddictionTreatment display_name_plural_all_caps]] "PATIENTS"),
		}),
	},
	RequiredResources = {
		"Money",
	},
	SortKey = 6,
	description = T(534780823915, --[[SectorOperation AddictionTreatment description]] "Send a merc to the Sanatorium for drug addiction recovery procedures"),
	display_name = T(281257586548, --[[SectorOperation AddictionTreatment display_name]] "Addiction Treatment"),
	group = "Custom Operations",
	icon = "UI/SectorOperations/T_Icon_Activity_Healing",
	id = "AddictionTreatment",
	image = "UI/Messages/Operations/quest_activity",
	log_msg_start = T(642307503754, --[[SectorOperation AddictionTreatment log_msg_start]] "<em><mercs></em> are <em>curing Larry from his addictions</em> in <SectorName(sector)>"),
	related_stat = "Health",
	short_name = T(945635026099, --[[SectorOperation AddictionTreatment short_name]] "Special"),
	sub_title = T(349906420202, --[[SectorOperation AddictionTreatment sub_title]] "Help this merc recover from drug addiction"),
	target_contribution = 7000,
})

PlaceObj('SectorOperation', {
	Custom = false,
	GetTimelineEventDescription = function (self, sector_id, eventcontext)
		return T(300844268409, "<em><Nick></em> will finish resting.")
	end,
	HasOperation = function (self, merc)
		return false
	end,
	OnRemoveOperation = function (self, merc)
		merc.wounds_being_treated = 0
		if merc.RestTimer>0 and (Game.CampaignTime - merc.RestTimer) >= const.Satellite.UnitTirednessRestTime then				
				merc:SetTired(Max(merc.Tiredness-1,0))
				merc.TravelTimerStart = 0
				merc.TravelTime = 0
		end
		merc.RestTimer = 0
	end,
	OnSetOperation = function (self, merc, arg)
		NetUpdateHash("OnSetOperation", self.id, merc.session_id)
		merc.wounds_being_treated = arg or PatientGetWoundedStacks(merc)
		merc.TravelTimerStart = 0
		if merc.RestTimer==0 then
			merc.RestTimer = Game.CampaignTime
		end
	end,
	Parameters = {
		PlaceObj('PresetParamNumber', {
			'Name', "HealPerTickBase",
			'Value', 10,
			'Tag', "<HealPerTickBase>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "HealWoundThreshold",
			'Value', 1000,
			'Tag', "<HealWoundThreshold>",
		}),
	},
	ProgressCurrent = function (self, merc, sector)
		return merc.heal_wound_progress or 0
	end,
	ProgressPerTick = function (self, merc, prediction)
		if merc.wounds_being_treated >0 then
			return self:ResolveValue("HealPerTickBase")
		end
		return 0
	end,
	SectorMercsTick = function (self, merc)
		local busy = (g_ActiveBanters and #g_ActiveBanters > 0) or IsSetpiecePlaying() or GetDialog("ConversationDialog")
		local time = (Game.CampaignTime - merc.RestTimer)
		if not busy and (time % const.Satellite.UnitIdleTime) < 50 then
			local mercs = GetOperationProfessionals(merc:GetSector().Id, self.id)
			local actor = table.interaction_rand(mercs,"IdleVR")
			if actor then
				PlayVoiceResponse(actor, "Idle")
			end
		end
	end,
	ShowInCombatBadge = false,
	Tick = function (self, merc)
		UnitHealPerTick(merc, self:ProgressPerTick(merc), self:ResolveValue("HealWoundThreshold"))
	end,
	description = T(173808267332, --[[SectorOperation Idle description]] "Resting allows the merc to recover from Exhausted and Tired status effects while also restoring wounds and HP slowly."),
	display_name = T(790926028376, --[[SectorOperation Idle display_name]] "Resting"),
	group = "Default",
	icon = "UI/SectorOperations/T_Icon_Activity_Resting",
	id = "Idle",
	operation_type = set( "Healing" ),
	short_name = T(997016580365, --[[SectorOperation Idle short_name]] "Resting"),
	sub_title = T(368518600566, --[[SectorOperation Idle sub_title]] "No current tasks"),
})

PlaceObj('SectorOperation', {
	BoostProgress = function (self, perc, sector)
		return 0
	end,
	CheckCompleted = function (self, merc, sector)
		if #GetOperationProfessionals(sector.Id, "HospitalTreatment") == 0 then
			self:Complete(sector)
		end
	end,
	Complete = function (self, sector)
		local mercs = GetOperationProfessionals(sector.Id, self.id)
		for _, merc in ipairs(mercs) do
			merc:SetTired(const.utNormal)
		end
		local merc_names = {}
		for _, merc in ipairs(mercs) do
			merc_names[#merc_names + 1] = merc.Nick
			merc:SetCurrentOperation("Idle")
		end
		self:OnComplete(sector, mercs)
		if next(merc_names) then
			CombatLog("important", T{379238071985, "<em><mercs></em> were discharged from the <em>hospital</em> in <SectorName(sector)>", mercs = ConcatListWithAnd(merc_names),operation = self.display_name, sector = sector})
		end
		Msg("OperationCompleted", self, mercs, sector)
	end,
	Custom = false,
	FilterAvailable = function (self, merc, profession)
		return merc:HasStatusEffect("Wounded")
	end,
	GetOperationCost = function (self, merc, profession, idx)
		local cost = PatientGetWoundedStacks(merc) * self:ResolveValue("MoneyPerWound")
		if HasPerk(merc, "Negotiator") then
			local discount = CharacterEffectDefs.Negotiator:ResolveValue("discountPercent")
			cost = cost - MulDivRound(cost, discount, 100)
		end
		local sector = merc:GetSector()
		local loyalty = GetCityLoyalty(sector.City)
		local diff = cost * self:ResolveValue("min_loyalty_cost_mul") - cost
		cost = cost + MulDivRound(100 - loyalty,  diff, 100) -- scale by loyalty
		return {[1] = {value = cost, resource = "Money"}}
	end,
	GetSectorSlots = function (self, prof)
		return 5
	end,
	HasOperation = function (self, sector)
		return sector.Hospital and not sector.HospitalLocked
	end,
	IsEnabled = function (self, sector)
		local min_loyalty = self:ResolveValue("MinRequiredLoyalty")
		local loyalty = GetCityLoyalty(sector.City)
		if loyalty < min_loyalty then
			return false, T{203480257255, "The minimum required loyalty is <num>", num = min_loyalty}
		end
		return true
	end,
	OnRemoveOperation = function (self, merc)
		if IsPatient(merc) then
			merc.wounds_being_treated = 0
		end
	end,
	OnSetOperation = function (self, merc, arg)
		if IsPatient(merc) then
			merc.wounds_being_treated = arg or PatientGetWoundedStacks(merc)
		end
	end,
	Parameters = {
		PlaceObj('PresetParamNumber', {
			'Name', "HealPerTickBase",
			'Value', 40,
			'Tag', "<HealPerTickBase>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "HealWoundThreshold",
			'Value', 500,
			'Tag', "<HealWoundThreshold>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "MinRequiredLoyalty",
			'Value', 5,
			'Tag', "<MinRequiredLoyalty>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "min_loyalty_cost_mul",
			'Value', 3,
			'Tag', "<min_loyalty_cost_mul>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "MoneyPerWound",
			'Value', 600,
			'Tag', "<MoneyPerWound>",
		}),
	},
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "Patient",
			'display_name', T(315415849045, --[[SectorOperation HospitalTreatment display_name]] "Patient"),
			'description', T(430226661540, --[[SectorOperation HospitalTreatment description]] "All wounds will be gradually removed from the Patient."),
			'display_name_all_caps', T(871372277605, --[[SectorOperation HospitalTreatment display_name_all_caps]] "PATIENT"),
			'display_name_plural', T(720206525718, --[[SectorOperation HospitalTreatment display_name_plural]] "Patients"),
			'display_name_plural_all_caps', T(330008328731, --[[SectorOperation HospitalTreatment display_name_plural_all_caps]] "PATIENTS"),
		}),
	},
	ProgressCompleteThreshold = function (self, merc, sector, prediction)
		if not merc or prediction~="Patient" then
			local slowest = 0
			for _, merc in ipairs(GetOperationProfessionals(sector.Id, self.id)) do
				slowest = Max(slowest, PatientGetWoundsBeingTreated(merc) * self:ResolveValue("HealWoundThreshold"))
			end
			return slowest
		end
		return PatientGetWoundsBeingTreated(merc) * self:ResolveValue("HealWoundThreshold")
	end,
	ProgressCurrent = function (self, merc, sector, prediction)
		if not merc or prediction~="Patient"  then
			local slowest = 0
			for _, merc in ipairs(GetOperationProfessionals(sector.Id, self.id)) do
				slowest = Max(slowest, merc.heal_wound_progress)
			end
			return slowest
		end
		return merc and merc.heal_wound_progress or 0
	end,
	ProgressPerTick = function (self, merc, prediction)
		local perTick = self:ResolveValue("HealPerTickBase")
		if HasPerk(merc, "JackOfAllTrades") then
			local mod = CharacterEffectDefs.JackOfAllTrades:ResolveValue("activityDurationMod")
			perTick = perTick + MulDivRound(perTick, mod, 100)
		end
		return perTick
	end,
	RequiredResources = {
		"Money",
	},
	SortKey = 1,
	Tick = function (self, merc)
		UnitHealPerTick(merc, self:ProgressPerTick(merc),self:ResolveValue("HealWoundThreshold"))
		if IsPatientReady(merc) then
		merc:SetCurrentOperation("Idle")
		end
		self:CheckCompleted(merc, merc:GetSector())
	end,
	description = T(586262778490, --[[SectorOperation HospitalTreatment description]] "Medical treatment in the local <em>hospital</em>. Faster than Treat Wounds operation. High cost in money but doesn't require Meds. High <em>Loyalty</em> in this sector decreases the cost of this Operation."),
	display_name = T(146919350469, --[[SectorOperation HospitalTreatment display_name]] "Hospital Treatment"),
	group = "Default",
	icon = "UI/SectorOperations/T_Icon_Activity_Healing_Doctor",
	id = "HospitalTreatment",
	image = "UI/Messages/Operations/hospital_treatment",
	log_msg_start = T(762794730763, --[[SectorOperation HospitalTreatment log_msg_start]] "<em><mercs></em> are in a <em>hospital</em> in <SectorName(sector)>"),
	operation_type = {
		Healing = true,
	},
	short_name = T(646731339835, --[[SectorOperation HospitalTreatment short_name]] "Hospital"),
	sub_title = T(448184527531, --[[SectorOperation HospitalTreatment sub_title]] "Medical facility is available"),
})

PlaceObj('SectorOperation', {
	BoostProgress = function (self, perc, sector)
		return 0
	end,
	CheckCompleted = function (self, merc, sector)
		if #GetOperationProfessionals(sector.Id, self.id, "Patient") == 0 then
			self:Complete(sector)
		end
	end,
	Complete = function (self, sector)
		local mercs = GetOperationProfessionals(sector.Id, self.id)
		local merc_names = {}
		local merc_doctors = table.map(GetOperationProfessionals(sector.Id, self.id,"Doctor"), function (o) return o.Nick end)
		
		for _, merc in ipairs(mercs) do
			merc_names[#merc_names + 1] = merc.Nick
			merc:SetCurrentOperation("Idle")
		end
		self:OnComplete(sector, mercs)
		if next(merc_doctors) then
			CombatLog("short",T{270791010368, "<em><doctors></em> finished treating wounds in <SectorName(sector)>",doctors = ConcatListWithAnd(merc_doctors), sector = sector})
		end
		Msg("OperationCompleted", self, mercs, sector)
	end,
	Custom = false,
	FilterAvailable = function (self, merc, profession)
		if profession == "Patient" then
			return merc:HasStatusEffect("Wounded")
		else
			return not self.min_requirement_stat or merc[self.min_requirement_stat] >= self.min_requirement_stat_value
		end
	end,
	GetOperationCost = function (self, merc, profession)
		if profession == "Patient" then
			return  {[1] = {value = self:ResolveValue("MedicalCostPerWound") * PatientGetWoundsBeingTreated(merc), resource = "Meds"}}
		else
			return {}
		end
	end,
	GetSectorSlots = function (self, prof, sector)
		if prof == "Patient" then
			return #GetOperationProfessionals(sector.Id, self.id, "Doctor") * self:ResolveValue("PatientSlotsPerDoctor")
		end
		return -1
	end,
	GetTimelineEventDescription = function (self, sector_id, eventcontext)
		local doctors, patients
		local evmercs, prof
		if eventcontext.mercs then
			evmercs = table.map(eventcontext.mercs, function(id) return gv_UnitData[id].Nick end)
			prof = eventcontext.profession
		end
		local mercs = GetOperationProfessionalsGroupedByProfession(sector_id, self.id)
		if prof then
			if prof=="Doctor" then
				doctors = evmercs 
				patients = mercs["Patient"]
				patients = table.map(patients, "Nick")
			else
				doctors = mercs["Doctor"]
				doctors = table.map(doctors, "Nick")
				patients = evmercs
			end
		else
			patients = mercs["Patient"]
			patients = table.map(patients, "Nick")
			doctors = mercs["Doctor"]
			doctors = table.map(doctors, "Nick")
		end
		patients = ConcatListWithAnd(patients)
		doctors = ConcatListWithAnd(doctors)
		return T{622566473650, "<em><doctors></em> will finish treating <em><patients></em>.", doctors = doctors, patients = patients}
	end,
	HasOperation = function (self, sector)
		return true
	end,
	IsEnabled = function (self, sector)
		local mercs_available = GetAvailableMercs(sector, self, "Doctor")
		local mercs_current = GetOperationProfessionals(sector.Id,"Doctor")
		if #mercs_available == 0 and #mercs_current == 0 then
			return false, T(449205258912, "No doctors available")
		end
		
		local mercs = GetPlayerMercsInSector(sector.Id)
		local wounded, wounded_unavailable
		for _, id in ipairs(mercs) do
			local unit = gv_UnitData[id]
			if unit:HasStatusEffect("Wounded") then
				if unit.Operation=="Idle" then
					wounded = true
				else
					wounded_unavailable = true
				end	
			end
		end
		if not wounded and  wounded_unavailable then
			return false, T(457589824008, "Wounded mercs are busy with another operation")
		elseif not wounded then
			return false, T(709401245024, "No wounded mercs")
		end
		
		return true
	end,
	OnRemoveOperation = function (self, merc)
		if IsPatient(merc) then
			merc.wounds_being_treated = 0
		end	
	end,
	OnSetOperation = function (self, merc, arg)
		if IsPatient(merc) then
			merc.wounds_being_treated = arg or PatientGetWoundedStacks(merc)
		end
		RecalcOperationETAs(merc:GetSector(), "TreatWounds")
	end,
	Parameters = {
		PlaceObj('PresetParamNumber', {
			'Name', "MedicalCostPerWound",
			'Value', 5,
			'Tag', "<MedicalCostPerWound>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "HealPerTickBase",
			'Value', 15,
			'Tag', "<HealPerTickBase>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "HealWoundThreshold",
			'Value', 1500,
			'Tag', "<HealWoundThreshold>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "PatientSlotsPerDoctor",
			'Value', 3,
			'Tag', "<PatientSlotsPerDoctor>",
		}),
	},
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "Doctor",
			'display_name', T(596832623341, --[[SectorOperation TreatWounds display_name]] "Doctor"),
			'description', T(285315118041, --[[SectorOperation TreatWounds description]] "The Doctor will gradually heal all wounds afflicting the Patients."),
			'display_name_all_caps', T(459432657543, --[[SectorOperation TreatWounds display_name_all_caps]] "DOCTOR"),
			'display_name_plural', T(967570481209, --[[SectorOperation TreatWounds display_name_plural]] "Doctors"),
			'display_name_plural_all_caps', T(160164246493, --[[SectorOperation TreatWounds display_name_plural_all_caps]] "DOCTORS"),
		}),
		PlaceObj('SectorOperationProfession', {
			'id', "Patient",
			'display_name', T(822808578753, --[[SectorOperation TreatWounds display_name]] "Patient"),
			'display_name_all_caps', T(138835778725, --[[SectorOperation TreatWounds display_name_all_caps]] "PATIENT"),
			'display_name_plural', T(880799219371, --[[SectorOperation TreatWounds display_name_plural]] "Patients"),
			'display_name_plural_all_caps', T(417811595364, --[[SectorOperation TreatWounds display_name_plural_all_caps]] "PATIENTS"),
		}),
	},
	ProgressCompleteThreshold = function (self, merc, sector, prediction)
		if not merc or prediction~="Patient" then
			local slowest = 0
			for _, merc in ipairs(GetOperationProfessionals(sector.Id, self.id, "Patient")) do
				slowest = Max(slowest, PatientGetWoundsBeingTreated(merc) * self:ResolveValue("HealWoundThreshold"))
			end
			return slowest
		end
		
		return (IsPatient(merc) or prediction=="Patient") and PatientGetWoundsBeingTreated(merc) * self:ResolveValue("HealWoundThreshold") or 0
	end,
	ProgressCurrent = function (self, merc, sector, prediction)
		if not merc or prediction~="Patient"  then
			local slowest = 0
			for _, merc in ipairs(GetOperationProfessionals(sector.Id, self.id, "Patient")) do
				slowest = Max(slowest, merc.heal_wound_progress)
			end
			return slowest
		end
		return (IsPatient(merc) or prediction=="Patient") and merc.heal_wound_progress or 0
	end,
	ProgressPerTick = function (self, merc, prediction)
		if IsPatient(merc) or prediction == "Patient" then
			local bonus = GetHealingBonus(merc:GetSector(), self.id)
			local perTick = MulDivRound(self:ResolveValue("HealPerTickBase"), bonus, 100)
			if HasPerk(merc, "JackOfAllTrades") then
				local mod = CharacterEffectDefs.JackOfAllTrades:ResolveValue("activityDurationMod")
				perTick = perTick + MulDivRound(perTick, mod, 100)
			end
			return perTick
		end
		return 0
	end,
	RequiredResources = {
		"Meds",
	},
	SectorOperationStats = function (self, sector, check_only)
		if check_only then return true end
		local lines = {}
		if self.min_requirement_stat and self.min_requirement_stat_value then
			local prop = table.find_value(UnitPropertiesStats:GetProperties(), "id", self.min_requirement_stat)
			lines[#lines + 1] = {text =  T{300232421689, "Min Required <name>", name = prop.name},value= T{139355455984, "<min_requirement_stat_value>", self}}
		end
		local factor = GetHealingBonus(sector, self.id)
		if factor<=100 then
			lines[#lines + 1] = {text = T(517619818105, "Healing Factor"), value = T{881588660903, "<percent(factor)>", factor = factor}}
		else
			lines[#lines + 1] = {text = T(517619818105, "Healing Factor"), value = T{985654435134, "<FormatAsFloat(factor, 100,1)>x", factor = factor}}
		end
		return lines, false
	end,
	SortKey = 10,
	Tick = function (self, merc)
		local sector = merc:GetSector()
		if IsPatient(merc) then
			UnitHealPerTick(merc, self:ProgressPerTick(merc),self:ResolveValue("HealWoundThreshold"))
			local doctors = GetOperationProfessionals(sector.Id, self.id,"Doctor")
			if IsPatientReady(merc) or #doctors<=0 then
				if merc.OperationProfessions and merc.OperationProfessions.Doctor then
					merc.OperationProfession = "Doctor"	
					merc:RemoveOperationProfession("Patient")					
				else
					if PatientGetWoundedStacks(merc)==0 then
						CombatLog("important", T{730468857355, "<merc_name> has been <em>cured of all wounds</em>", merc_name = merc.Nick})
					end
					merc:SetCurrentOperation("Idle")
				end
			end
		end
		if IsDoctor(merc) then
			self:CheckCompleted(merc, sector)
		end
	end,
	description = T(504649175249, --[[SectorOperation TreatWounds description]] "Mercs with high <em>Medical</em> skill can treat the wounds of other mercs and themselves at the cost of <em>Meds</em>."),
	display_name = T(330904449687, --[[SectorOperation TreatWounds display_name]] "Treat Wounds"),
	group = "Default",
	icon = "UI/SectorOperations/T_Icon_Activity_Healing",
	id = "TreatWounds",
	image = "UI/Messages/Operations/treat_wounds",
	min_requirement_stat = "Medical",
	min_requirement_stat_value = 30,
	operation_type = {
		Healing = true,
	},
	related_stat = "Medical",
	short_name = T(877828949933, --[[SectorOperation TreatWounds short_name]] "Healing"),
	sub_title = T(355420939253, --[[SectorOperation TreatWounds sub_title]] "Spend Meds to heal wounded mercs"),
})

PlaceObj('SectorOperation', {
	CanPerformOperation = function (self, merc, profession)
		local sector = merc:GetSector()
		local context = {activity = self.display_name}
		if #GetAvailableIntelSectors(sector.Id) == 0 then
			return "OperationNoIntelItems", context
		else
			return	self:CanPerformOperationBase(merc)
		end	
	end,
	Custom = false,
	GetDescription = function (self, merc)
		local squad = gv_Squads[merc.Squad]
		local sector_id = squad and squad.CurrentSector
		return T{self.description}
	end,
	GetSectorSlots = function (self, prof, sector)
		return 2
	end,
	GetTimelineEventDescription = function (self, sector_id, eventcontext)
		local mercs
		local professionId = self.Professions and self.Professions[1] and self.Professions[1].id
		if eventcontext.mercs then
			mercs = table.map(eventcontext.mercs, function(id) return gv_UnitData[id].Nick end)
		else
			mercs = GetOperationProfessionalsGroupedByProfession(sector_id, self.id)
			mercs = table.map(professionId and mercs[professionId] or mercs, "Nick")
		end
		mercs = ConcatListWithAnd(mercs)
		return T{104423723687, "<em><mercs></em> will gather intel for a nearby sector.", mercs = mercs}
	end,
	IsEnabled = function (self, sector)
		if #GetAvailableIntelSectors(sector.Id) == 0 then
			return false,  T(232903998446, "No intel to be gathered.")
		end
		return true
	end,
	OnComplete = function (self, sector, mercs)
		local text = HandleGatherIntelCompleted(sector.Id, mercs)
		sector.intel_progress = 0
		local popup = true
		if InteractionRand(100, "EventOutcome") <= self:ResolveValue("outcome_chance") then
			-- get outcome
			local weights = {}
			for id,event in sorted_pairs(EventOperationsOutcomes) do
				if event:Condition(self.Id, sector,  mercs) then
					weights[#weights+1] = {event:GetWeight(self.Id, sector,  mercs), event}
				end
			end
			local event = GetWeightedRandom(weights, InteractionRand(nil, "EventOutcome"))
			if event then
				ShowPopupNotification(event.PopupId, {base_activity_info = text or "", event})
				popup = false
				event:Effect(self.Id, sector,  mercs)
			end	
		end
		if popup and text then
			ShowPopupNotification("GatherIntelBase", {base_activity_info = text or ""})
		end
	end,
	Parameters = {
		PlaceObj('PresetParamNumber', {
			'Name', "threshold_per_sector",
			'Value', 1500,
			'Tag', "<threshold_per_sector>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "base_progress_per_tick",
			'Value', 60,
			'Tag', "<base_progress_per_tick>",
		}),
		PlaceObj('PresetParamPercent', {
			'Name', "outcome_chance",
			'Value', 70,
			'Tag', "<outcome_chance>%",
		}),
	},
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "Spy",
			'display_name', T(691679429214, --[[SectorOperation GatherIntel display_name]] "Scout"),
			'description', T(189541578746, --[[SectorOperation GatherIntel description]] "The Scout will gather Intel about the surrounding Sectors."),
			'display_name_all_caps', T(624273298766, --[[SectorOperation GatherIntel display_name_all_caps]] "SCOUT"),
			'display_name_plural', T(870067143604, --[[SectorOperation GatherIntel display_name_plural]] "Scouts"),
			'display_name_plural_all_caps', T(891172203689, --[[SectorOperation GatherIntel display_name_plural_all_caps]] "SCOUTS"),
		}),
	},
	ProgressCompleteThreshold = function (self, merc, sector)
		return self:ResolveValue("threshold_per_sector") * #GetAvailableIntelSectors(sector.Id)
	end,
	ProgressCurrent = function (self, merc, sector)
		return sector.intel_progress or 0
	end,
	ProgressPerTick = function (self, merc, prediction)
		local perTick = self:ResolveValue("base_progress_per_tick") * (100 + Max(0,(merc.Wisdom-50)*2))/100
		if HasPerk(merc, "JackOfAllTrades") then
			local mod = CharacterEffectDefs.JackOfAllTrades:ResolveValue("activityDurationMod")
			perTick = perTick + MulDivRound(perTick, mod, 100)
		end
		return perTick
	end,
	SortKey = 20,
	Tick = function (self, merc)
		local sector = merc:GetSector()
		local progress_per_tick = self:ProgressPerTick(merc)
		if CheatEnabled("FastActivity") then
			progress_per_tick = progress_per_tick*100
		end
		sector.intel_progress = sector.intel_progress + progress_per_tick
		self:CheckCompleted(merc, sector)
	end,
	description = T(557088134133, --[[SectorOperation GatherIntel description]] "Scout the area within two sectors range and contact the locals to gather <em>Intel</em> about nearby sectors. Assigning mercs with high <em>Wisdom</em> increases the speed of the Operation."),
	display_name = T(631657879501, --[[SectorOperation GatherIntel display_name]] "Scout Area"),
	error_msg = T(297357096163, --[[SectorOperation GatherIntel error_msg]] "<flavor>There is no new Intel in this area.</flavor>"),
	group = "Default",
	icon = "UI/SectorOperations/T_Icon_Activity_Scouting",
	id = "GatherIntel",
	image = "UI/Messages/Operations/scout",
	log_msg_start = T(118398177729, --[[SectorOperation GatherIntel log_msg_start]] "<em><mercs></em> started <em>Scouting</em> in <SectorName(sector)>"),
	related_stat = "Wisdom",
	short_name = T(804167973032, --[[SectorOperation GatherIntel short_name]] "Scouting"),
	sub_title = T(197881567327, --[[SectorOperation GatherIntel sub_title]] "Gather Intel for nearby sectors"),
})

PlaceObj('SectorOperation', {
	Complete = function (self, sector)
		local mercs = GetOperationProfessionals(sector.Id, self.id)
		local merc_names = {}
		for _, merc in ipairs(mercs) do
			merc_names[#merc_names + 1] = merc.Nick
			merc:SetCurrentOperation("Idle")
		end
		self:OnComplete(sector, mercs)
		if next(merc_names) then
			CombatLog("important", T{258083168009, "<em><mercs></em> completed <em><activity></em> in <SectorName(sector)>", mercs = ConcatListWithAnd(merc_names),activity = self.display_name, sector = sector})
		end
		Msg("OperationCompleted", self, mercs, sector)
	end,
	Custom = false,
	GetAssignMessage = function (self, nameCombination, costTexts)
		costTexts = table.concat(costTexts, T(642697486575, ", "))
		return T{253336352123, "Training the locals to fight will require some additional funds. Do you want to pay <costTexts>", names = nameCombination, costTexts = costTexts}
	end,
	GetOperationCost = function (self, merc, profession, idx)
		local sector = merc:GetSector()
		local other = GetOperationProfessionals(sector.Id, self.id, false, merc.session_id) 
		if sector.militia_training and #other>0 and idx~="refund" then
			return {}
		end
		local cost = sector and sector.MilitiaTrainingCost
		if HasPerk(merc, "Negotiator") then
			local discount = CharacterEffectDefs.Negotiator:ResolveValue("discountPercent")
			cost = cost - MulDivRound(cost, discount, 100)
		end
		local loyalty = sector and GetCityLoyalty(sector.City) or 100
		local diff = cost * self:ResolveValue("min_loyalty_cost_mul") - cost
		return {[1] = {value = cost + (100 - loyalty) * diff / 100, resource = "Money", min = true}}
	end,
	GetSectorSlots = function (self, prof)
		return 2
	end,
	GetTimelineEventDescription = function (self, sector_id, eventcontext)
		local mercs
		local professionId = self.Professions and self.Professions[1] and self.Professions[1].id
		if eventcontext.mercs then
			mercs = table.map(eventcontext.mercs, function(id) return gv_UnitData[id].Nick end)
		else
			mercs = GetOperationProfessionalsGroupedByProfession(sector_id, self.id)
			mercs = table.map(professionId and mercs[professionId] or mercs, "Nick")
		end
		mercs = ConcatListWithAnd(mercs)
		return T{342825966200, "<em><mercs></em> will finish training militia.", mercs = mercs}
	end,
	HasOperation = function (self, sector)
		return sector.Militia
	end,
	IsEnabled = function (self, sector)
		local militia_squad_id = sector.militia_squad_id 
		if not militia_squad_id then return true end
		local militia_squad = gv_Squads[militia_squad_id]
		if #(militia_squad.units or "") < sector.MaxMilitia then return true end	
		
		local ud = GetLeastExpMilitia(militia_squad.units)
		local least_exp_templ = ud and ud.class
		if least_exp_templ == "MilitiaVeteran" or least_exp_templ=="MilitiaElite" then 
			return false , T(764949488129, "Reached militia limit")
		end
		return true
	end,
	ModifyProgress = function (self, value, sector)
		sector.militia_training_progress = sector.militia_training_progress + value
	end,
	OnComplete = function (self, sector, mercs)
		CompleteCurrentMilitiaTraining(sector, mercs)
		sector.militia_training_progress = 0
	end,
	OnRemoveOperation = function (self, merc)
		local sector = merc:GetSector()
		local workers = GetOperationProfessionals(sector.Id, self.id, false, merc.session_id) or {}
		sector.militia_training = #workers>0
	end,
	OnSetOperation = function (self, merc)
		local sector = merc:GetSector()
		sector.militia_training = true
	end,
	Parameters = {
		PlaceObj('PresetParamNumber', {
			'Name', "min_progress",
			'Value', 10,
			'Tag', "<min_progress>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "max_progress",
			'Value', 25,
			'Tag', "<max_progress>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "min_loyalty_cost_mul",
			'Value', 3,
			'Tag', "<min_loyalty_cost_mul>",
		}),
	},
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "Trainer",
			'display_name', T(628386518879, --[[SectorOperation MilitiaTraining display_name]] "Trainer"),
			'description', T(464932729153, --[[SectorOperation MilitiaTraining description]] "The Trainer is working with the locals turning them into Militia troops."),
			'display_name_all_caps', T(664253699370, --[[SectorOperation MilitiaTraining display_name_all_caps]] "TRAINER"),
			'display_name_plural', T(625255760689, --[[SectorOperation MilitiaTraining display_name_plural]] "Trainers"),
			'display_name_plural_all_caps', T(501735364008, --[[SectorOperation MilitiaTraining display_name_plural_all_caps]] "TRAINERS"),
		}),
	},
	ProgressCompleteThreshold = function (self, merc)
		return const.Satellite.MilitiaTrainingThreshold
	end,
	ProgressCurrent = function (self, merc, sector)
		return sector.militia_training_progress or 0
	end,
	ProgressPerTick = function (self, merc, prediction)
		local sector = merc:GetSector()
		local min_progress = self:ResolveValue("min_progress")
		local max_progress = self:ResolveValue("max_progress")
		local progress = min_progress + (merc.Leadership) * (max_progress - min_progress) / 100
		if HasPerk(merc, "Teacher") then
			local trainingBonusPercent = CharacterEffectDefs.Teacher:ResolveValue("MilitiaTrainingBonusPercent") 
			progress = progress + MulDivRound(progress, trainingBonusPercent, 100)
		end
		if HasPerk(merc, "JackOfAllTrades") then
			local mod = CharacterEffectDefs.JackOfAllTrades:ResolveValue("activityDurationMod")
			progress = progress + MulDivRound(progress, mod, 100)
		end
		return progress
	end,
	RequiredResources = {
		"Money",
	},
	SectorOperationStats = function (self, sector, check_only)
		if check_only then return true end
		
		local lines = {}
		lines[#lines + 1] = {text = T(231988048655, "City Loyalty"), value = T{257328164584, "<percent(value)>", value = sector.City ~= "none" and gv_Cities[sector.City].Loyalty or 0}}
		local progressVal = MulDivRound(sector.militia_training_progress, 100, self:ProgressCompleteThreshold())
			
		local militia_squad_id = sector.militia_squad_id 	
		local militia_squad = militia_squad_id and gv_Squads[militia_squad_id]
		lines[#lines + 1] = {text = T(718591666122, "Active Militia"), value  = T{702630905213, "<current>/<max>", current =  #(militia_squad and militia_squad.units or ""), max =sector.MaxMilitia }}
		
		return lines, progressVal
	end,
	SortKey = 30,
	StoreAsTable = true,
	description = T(937310534976, --[[SectorOperation MilitiaTraining description]] "Whip the civilian population into shape, turning them into a local Militia able to defend against hostile troops. Picking a Trainer with high <em>Leadership</em> and a high <em>Loyalty</em> of the local population both contribute to faster training."),
	display_name = T(260961542074, --[[SectorOperation MilitiaTraining display_name]] "Militia Training"),
	group = "Default",
	icon = "UI/SectorOperations/T_Icon_Activity_TrainingMilitia",
	id = "MilitiaTraining",
	image = "UI/Messages/Operations/train_militia",
	log_msg_start = T(585108745283, --[[SectorOperation MilitiaTraining log_msg_start]] "<em><mercs></em> started <em>training Militia</em> in <SectorName(sector)>"),
	param_bindings = {},
	related_stat = "Leadership",
	short_name = T(987856035425, --[[SectorOperation MilitiaTraining short_name]] "Militia"),
	sub_title = T(649454746324, --[[SectorOperation MilitiaTraining sub_title]] "Militia training is available"),
})

PlaceObj('SectorOperation', {
	Complete = function (self, sector)
		local stat = sector.training_stat
		local prop_meta = table.find_value(UnitPropertiesStats:GetProperties(), "id", stat)
		local stat_name = prop_meta.name	
		
		local mercs = GetOperationProfessionals(sector.Id, self.id, "Student")
		
		local merc_names = {}		
		for _, merc in ipairs(mercs) do	
			if merc.stat_learning then
				local learning_data = merc.stat_learning[stat] or empty_table
				local up_levels  = learning_data.up_levels or 0
				local progress = learning_data.progress or 0
				merc_names[up_levels] = merc_names[up_levels] or  {} 
				table.insert(merc_names[up_levels],merc.Nick)	
				if merc.stat_learning[stat] then
					merc.stat_learning[stat].up_levels = 0
				end
			end
		end
		
		local mercs = GetOperationProfessionals(sector.Id, self.id)
		for _, merc in ipairs(mercs) do
			merc:SetCurrentOperation("Idle")			
		end
		self:OnComplete(sector, mercs)
		if next (merc_names) then
			CombatLog("important", T{449926986206, "<stat_name> Training (<sector_id>) finished.",stat_name = stat_name, sector_id = Untranslated(sector.Id)})
			for up_levels, names in sorted_pairs(merc_names) do
				if up_levels == 0 then
					CombatLog("important", T{964788160766, "<merc_names> improved but not enough to gain a stat increase.", merc_names = ConcatListWithAnd(names) })
				else
					CombatLog("important", T{124938068325, "<em><unit></em> gained +<amount> <em><stat></em>",stat = stat_name, amount = Untranslated(up_levels), unit = ConcatListWithAnd(names)})
				end
			end					
		end
		Msg("OperationCompleted", self, mercs, sector)
	end,
	Custom = false,
	FilterAvailable = function (self, merc, profession)
		local sector = merc:GetSector()
		local stat = sector.training_stat
		if stat and profession == "Student" then
			if HasPerk(merc, "OldDog") then return false end
			local teachers = GetOperationProfessionals(sector.Id, self.id, "Teacher")
			local teacher = teachers[1]
			if not teacher then return false end
			return  teacher[stat]>merc[stat]
		else-- teacher
			return stat and  merc[sector.training_stat] >= self.min_requirement_stat_value
		end
	end,
	GetRelatedStat = function (self, merc)
		local sector =  merc:GetSector()
		local stat = sector.training_stat
		if stat then
			return stat, merc[stat]
		end
	end,
	GetSectorSlots = function (self, prof, sector)
		if prof == "Student" then
			return  -1
		end
		return 1
	end,
	GetTimelineEventDescription = function (self, sector_id, eventcontext)
		local teachers, students
		local evmercs, prof
		if eventcontext.mercs then
			evmercs = table.map(eventcontext.mercs, function(id) return gv_UnitData[id].Nick end)
			prof = eventcontext.profession
		end
		local mercs = GetOperationProfessionalsGroupedByProfession(sector_id, self.id)
		if prof then
			if prof=="Teacher" then
				teachers = evmercs 
				students = mercs["Student"]
				students = table.map(students, "Nick")
			else
				teachers = mercs["Teacher"]
				teachers = table.map(teachers, "Nick")
				students = evmercs
			end
		else
			students = mercs["Student"]
			students = table.map(students, "Nick")
			teachers = mercs["Teacher"]
			teachers = table.map(teachers, "Nick")
		end
		students = ConcatListWithAnd(students)
		teachers = ConcatListWithAnd(teachers)
		
		return T{793160161691, "<em><teachers></em> will finish training <em><students></em>.", teachers = teachers, students = students}
	end,
	HasOperation = function (self, sector)
		return true
	end,
	IsEnabled = function (self, sector)
		return true
	end,
	OnRemoveOperation = function (self, merc)
		merc.training_activity_progress = 0
	end,
	OnSetOperation = function (self, merc, arg)
		merc.training_activity_progress = 0
		if merc.OperationProfession=="Student" then
			local sector = merc:GetSector()
			local stat = sector.training_stat
			if merc.stat_learning and merc.stat_learning[stat] then
				merc.stat_learning[stat].up_levels = 0
			end
			return  merc.stat_learning and merc.stat_learning[stat] and merc.stat_learning[stat].progress or 0
		end
		RecalcOperationETAs(merc:GetSector(), "TrainMercs")		
	end,
	Parameters = {
		PlaceObj('PresetParamNumber', {
			'Name', "ActivityDurationInHoursFull",
			'Value', 48,
			'Tag', "<ActivityDurationInHoursFull>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "PerTickProgress",
			'Value', 400,
			'Tag', "<PerTickProgress>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "learning_speed",
			'Value', 250,
			'Tag', "<learning_speed>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "wisdow_weight",
			'Value', 50,
			'Tag', "<wisdow_weight>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "learning_base_bonus",
			'Value', 25,
			'Tag', "<learning_base_bonus>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "max_learned_stat",
			'Value', 90,
			'Tag', "<max_learned_stat>",
		}),
	},
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "Teacher",
			'display_name', T(367499556384, --[[SectorOperation TrainMercs display_name]] "Teacher"),
			'description', T(276227630311, --[[SectorOperation TrainMercs description]] "The Teacher will help the Students learn the selected skill."),
			'display_name_all_caps', T(963010106383, --[[SectorOperation TrainMercs display_name_all_caps]] "TEACHER"),
			'display_name_plural', T(710939217002, --[[SectorOperation TrainMercs display_name_plural]] "Teachers"),
			'display_name_plural_all_caps', T(531887347914, --[[SectorOperation TrainMercs display_name_plural_all_caps]] "TEACHERS"),
		}),
		PlaceObj('SectorOperationProfession', {
			'id', "Student",
			'display_name', T(154372383055, --[[SectorOperation TrainMercs display_name]] "Student"),
			'description', T(976396278650, --[[SectorOperation TrainMercs description]] "Students train a selected attribute over time. The higher the attribute the more time it takes to increase it."),
			'display_name_all_caps', T(645304016874, --[[SectorOperation TrainMercs display_name_all_caps]] "STUDENT"),
			'display_name_plural', T(699217248789, --[[SectorOperation TrainMercs display_name_plural]] "Students"),
			'display_name_plural_all_caps', T(109439951366, --[[SectorOperation TrainMercs display_name_plural_all_caps]] "STUDENTS"),
		}),
	},
	ProgressCompleteThreshold = function (self, merc, sector, prediction)
		--2 days,each tick is in 15min => 48*4 and scale 1000
		return self:ResolveValue("ActivityDurationInHoursFull")*4*self:ResolveValue("PerTickProgress")
	end,
	ProgressCurrent = function (self, merc, sector, prediction)
		if not merc then
			local mercs = GetOperationProfessionals(sector.Id, self.id, "Teacher")
			merc = mercs[1]
		end	
		return merc and merc.training_activity_progress or 0
	end,
	ProgressPerTick = function (self, merc, prediction)
		local progressPerTick = self:ResolveValue("PerTickProgress")
		if merc and HasPerk(merc, "JackOfAllTrades") then
			local mod = CharacterEffectDefs.JackOfAllTrades:ResolveValue("activityDurationMod")
			progressPerTick = progressPerTick + MulDivRound(progressPerTick, mod, 100)
		end
		if CheatEnabled("FastActivity") then
			progressPerTick = progressPerTick*100
		end
		
		return progressPerTick
	end,
	SectorMercsTick = function (self, merc)
		local sector = merc:GetSector()
		local teacher = GetOperationProfessionals(sector.Id, self.id, "Teacher")
		local progress_per_tick = self:ProgressPerTick(teacher[1])
		local to_complete 
		merc.training_activity_progress = merc.training_activity_progress + progress_per_tick
		to_complete = self:ProgressCurrent(merc, sector) >= self:ProgressCompleteThreshold(merc, sector)
		merc.training_activity_progress = merc.training_activity_progress - progress_per_tick
		
		if not to_complete then
			local teachers = GetOperationProfessionals(sector.Id, self.id, "Teacher")
			if  not next(teachers) then
				to_complete = true
			end
		end
		if not to_complete then
			local students = GetOperationProfessionals(sector.Id, self.id, "Student")
			if not next(students) then
				to_complete = true
			end
		end
		-- call all mercs tick and complete after that		
		local mercs = GetOperationProfessionals(sector.Id, self.id)
		table.insert_unique(mercs, merc)
		for _, m in ipairs( mercs) do
			if to_complete then
				self:Tick(m)
			end
			m.training_activity_progress = m.training_activity_progress + progress_per_tick
		end
		if to_complete then
			self:Complete(sector)
		end		
	end,
	SortKey = 40,
	Tick = function (self, merc)
		--Learning speed parameter defines the treshold of how much must be gained to gain 1 in a stat. Bigger number means slower.
		
		local sector = merc:GetSector()
		local stat = sector.training_stat
		if self:ProgressCurrent(merc, sector) >= self:ProgressCompleteThreshold(merc, sector) then
			return 
		end	
		local max_learned_stat = self:ResolveValue("max_learned_stat")
		if merc.OperationProfession=="Student" then
			local teachers = GetOperationProfessionals(sector.Id, self.id, "Teacher")
			local teacher = teachers[1]
			if not teacher then
				return
			end
		else-- teacher
			local students = GetOperationProfessionals(sector.Id, self.id, "Student")
			local t_stat = merc[stat]
			for _, student in ipairs(students) do
				local is_learned_max = student[stat]>=t_stat or student[stat]>max_learned_stat
				if not is_learned_max then
					student.stat_learning = student.stat_learning or {}
					local progressPerTick = MulDivRound(t_stat,100 + merc.Leadership, 100) + self:ResolveValue("learning_base_bonus") 
					if HasPerk(merc, "Teacher") then
						local bonusPercent = CharacterEffectDefs.Teacher:ResolveValue("MercTrainingBonus")
						progressPerTick = progressPerTick + MulDivRound(progressPerTick, bonusPercent, 100)
					end
					student.stat_learning[stat] = student.stat_learning[stat] or {progress = 0, up_levels = 0}
					local learning_progress = student.stat_learning[stat].progress
					learning_progress = learning_progress + progressPerTick
					
					local progress_threshold = self:ResolveValue("learning_speed")*student[stat]*(100+self:ResolveValue("wisdow_weight") - Max(0,(student.Wisdom-50)*2))/100 
					if learning_progress >= progress_threshold then
						local gainAmount = 1
						local modId = string.format("StatTraining-%s-%s-%d", stat, student.session_id, GetPreciseTicks())
						GainStat(student, stat, gainAmount, modId, "Training")
			
						PlayVoiceResponse(student, "TrainingReceived")
						--CombatLog("important",T{424323552240, "<merc_nickname> gained +1 <stat_name> from training in <sector_id>", stat_name = stat_name, merc_nickname  =  student.Nick, sector_id = Untranslated(sector.Id)})
						learning_progress = 0
						student.stat_learning[stat].up_levels = student.stat_learning[stat].up_levels + 1
					end
					student.stat_learning[stat].progress = learning_progress
				end
			end
		end
		local students = GetOperationProfessionals(sector.Id, self.id, "Student")
		if not next(students) then
		--	self:Complete(sector)
			return
		end
	end,
	description = T(536262688463, --[[SectorOperation TrainMercs description]] "Assign a Trainer to improve the stats of the other mercs. The trainer must have a higher stat than the trained mercs."),
	display_name = T(555520982832, --[[SectorOperation TrainMercs display_name]] "Train mercs"),
	group = "Default",
	icon = "UI/SectorOperations/T_Icon_Activity_TrainingMercs_Teacher",
	id = "TrainMercs",
	image = "UI/Messages/Operations/train_merc",
	min_requirement_stat_value = 50,
	short_name = T(992286698650, --[[SectorOperation TrainMercs short_name]] "Training"),
	sub_title = T(710786801755, --[[SectorOperation TrainMercs sub_title]] "Spend some time to improve merc stats"),
})

PlaceObj('SectorOperation', {
	CheckCompleted = function (self, merc, sector)
		if self:ProgressCurrent(merc[1], sector) >= self:ProgressCompleteThreshold(merc[1], sector) then
			local mercs = merc--GetOperationProfessionals(sector.Id, self.id)
			self:OnComplete(sector, mercs)
			local merc_names = {}
			-- move the merc that completed the operation last, because of the interrupt logic
			local count = #mercs
			for i=count,1, -1 do
				local m =  mercs[i]
			  	if self:ProgressCurrent(m, sector) >= self:ProgressCompleteThreshold(m, sector) then
						table.remove(mercs, i)
						table.insert(mercs, m)
					end
		    end
			for _, merc in ipairs(mercs) do
				merc_names[#merc_names + 1] = merc.Nick
				merc:SetCurrentOperation("Idle")
			end			
			if next(merc_names) then
				CombatLog("important", T{701411441832, "<em><mercs></em> finished <em>relaxing</em> in <SectorName(sector)>", mercs = ConcatListWithAnd(merc_names), sector = sector})
			end
			Msg("OperationCompleted", self, mercs, sector)
		end
	end,
	Complete = function (self, sector)
		local mercs = GetOperationProfessionals(sector.Id, self.id)
		local merc_names = {}
		for _, merc in ipairs(mercs) do
			merc_names[#merc_names + 1] = merc.Nick
			merc:SetCurrentOperation("Idle")
		end
		self:OnComplete(sector, mercs)
		if next(merc_names) then
			CombatLog("important", T{701411441832, "<em><mercs></em> finished <em>relaxing</em> in <SectorName(sector)>", mercs = ConcatListWithAnd(merc_names), sector = sector})
		end
		Msg("OperationCompleted", self, mercs, sector)
	end,
	Custom = false,
	GetOperationCost = function (self, merc, profession, idx)
		local sector = merc:GetSector()
		local loyalty = sector and GetCityLoyalty(sector.City) or 100
		local money_cost = self:ResolveValue("MoneyCostBase")
		if HasPerk(merc, "Negotiator") then
			local discount = CharacterEffectDefs.Negotiator:ResolveValue("discountPercent")
			money_cost = money_cost - MulDivRound(money_cost, discount, 100)
		end
		local money_cost_reduce = self:ResolveValue("MoneyCostLoyaltyReduce")
		local cost = money_cost -  MulDivRound(money_cost_reduce, loyalty, 100)
		return {[1] = {value = cost, resource = "Money"}}
	end,
	GetSectorSlots = function (self, prof, sector)
		return -1
	end,
	GetTimelineEventDescription = function (self, sector_id, eventcontext)
		return T(300844268409, "<em><Nick></em> will finish resting.")
	end,
	HasOperation = function (self, sector)
		return sector.RAndRAllowed
	end,
	OnComplete = function (self, sector, mercs)
		local scale = 4*self:ResolveValue("PerTickProgress") 
		for _,merc in ipairs(mercs) do	
			local progress = merc.randr_activity_progress
			if progress>=self:ResolveValue("ActivityDurationInHoursFull")*scale then
				merc:SetTired(const.utWellRested)
			elseif progress>=self:ResolveValue("ActivityDurationInHoursReduced")*scale then	
				merc:SetTired(Min(merc.Tiredness,0))
			elseif progress>=self:ResolveValue("ActivityDurationInHoursMin")*scale then	
				merc:SetTired(Max(merc.Tiredness-1, 0))
			end	
		end
	end,
	OnRemoveOperation = function (self, merc)
		self:OnComplete(merc:GetSector(), {merc})
		merc.randr_activity_progress = 0
		merc.wounds_being_treated = 0
	end,
	OnSetOperation = function (self, merc, arg)
		merc.randr_activity_progress = 0
		merc.wounds_being_treated = arg or PatientGetWoundedStacks(merc)
	end,
	Parameters = {
		PlaceObj('PresetParamNumber', {
			'Name', "HealPerTickBase",
			'Value', 14,
			'Tag', "<HealPerTickBase>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "HealWoundThreshold",
			'Value', 900,
			'Tag', "<HealWoundThreshold>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "MoneyCostBase",
			'Value', 250,
			'Tag', "<MoneyCostBase>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "MoneyCostLoyaltyReduce",
			'Value', 200,
			'Tag', "<MoneyCostLoyaltyReduce>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "ActivityDurationInHoursReduced",
			'Value', 8,
			'Tag', "<ActivityDurationInHoursReduced>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "ActivityDurationInHoursMin",
			'Value', 6,
			'Tag', "<ActivityDurationInHoursMin>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "ActivityDurationInHoursFull",
			'Value', 18,
			'Tag', "<ActivityDurationInHoursFull>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "PerTickProgress",
			'Value', 800,
			'Tag', "<PerTickProgress>",
		}),
	},
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "Restman",
			'display_name', T(844979991697, --[[SectorOperation RAndR display_name]] "Resting merc"),
			'description', T(171281723580, --[[SectorOperation RAndR description]] "The Resting Mercs are actively resting restoring their strength for the coming fights."),
			'display_name_all_caps', T(384931167235, --[[SectorOperation RAndR display_name_all_caps]] "RESTING MERC"),
			'display_name_plural', T(193397733757, --[[SectorOperation RAndR display_name_plural]] "Resting mercs"),
			'display_name_plural_all_caps', T(734798876334, --[[SectorOperation RAndR display_name_plural_all_caps]] "RESTING MERCS"),
		}),
	},
	ProgressCompleteThreshold = function (self, merc, sector, prediction)
		--8h,each tick is in 15min => 8*4 and scale 1000
		return self:ResolveValue("ActivityDurationInHoursFull")*4*self:ResolveValue("PerTickProgress")
	end,
	ProgressCurrent = function (self, merc, sector)
		return merc and merc.randr_activity_progress or 0
	end,
	ProgressPerTick = function (self, merc, prediction)
		local perTick = self:ResolveValue("PerTickProgress")
		if HasPerk(merc, "JackOfAllTrades") then
			local mod = CharacterEffectDefs.JackOfAllTrades:ResolveValue("activityDurationMod")
			perTick = perTick + MulDivRound(perTick, mod, 100)
		end
		return perTick
	end,
	RequiredResources = {
		"Money",
	},
	SectorMercsTick = function (self, merc)
		local sector = merc:GetSector()
		local mercs = GetOperationProfessionals(sector.Id, self.id)
		table.insert_unique(mercs, merc)
		
		local completed  = {}
		for _, m in ipairs( mercs) do
			UnitHealPerTick(m,self:ResolveValue("HealPerTickBase"), self:ResolveValue("HealWoundThreshold"))
			local progress_per_tick = self:ProgressPerTick(m)
			if CheatEnabled("FastActivity") then
				progress_per_tick = progress_per_tick*100
			end
			m.randr_activity_progress = m.randr_activity_progress + progress_per_tick
			if self:ProgressCurrent(m, sector) >= self:ProgressCompleteThreshold(m, sector) then
				completed[#completed +1] = m
			end
		end
		if next(completed) then	
			self:CheckCompleted(completed, sector)	
		end
	end,
	SortKey = 45,
	Tick = function (self, merc)
		return
	end,
	description = T(949954465731, --[[SectorOperation RAndR description]] "Spend some time for active rest and entertainment. HP are restored faster, Wounds naturally heal faster, and all exhaustion effects are removed."),
	display_name = T(701547833503, --[[SectorOperation RAndR display_name]] "R&R"),
	group = "Default",
	icon = "UI/SectorOperations/T_Icon_Activity_R_R",
	id = "RAndR",
	image = "UI/Messages/Operations/r&r",
	log_msg_start = T(985871576966, --[[SectorOperation RAndR log_msg_start]] "<em><mercs></em> started <em>relaxing</em> in <SectorName(sector)>"),
	operation_type = set( "Healing" ),
	short_name = T(807604804677, --[[SectorOperation RAndR short_name]] "R&R"),
	sub_title = T(324618473774, --[[SectorOperation RAndR sub_title]] "Rest and Recreation"),
})

PlaceObj('SectorOperation', {
	CanPerformOperation = function (self, merc)
		local context = {activity = self.display_name}
		if merc.Mechanical == 0 then
			return "OperationMechanicalStatError", context
		else
			return self:CanPerformOperationBase(merc)
		end	
	end,
	Complete = function (self, sector)
		local mercs = GetOperationProfessionals(sector.Id, self.id)
		local merc_names = {}
		for _, merc in ipairs(mercs) do
			merc_names[#merc_names + 1] = merc.Nick
			merc:SetCurrentOperation("Idle")
		end
		self:OnComplete(sector, mercs)
		if next(merc_names) then
			CombatLog("important", T{258083168009, "<em><mercs></em> completed <em><activity></em> in <SectorName(sector)>", mercs = ConcatListWithAnd(merc_names),activity = self.display_name, sector = sector})
		end
		Msg("OperationCompleted", self, mercs, sector)
	end,
	Custom = false,
	GetSectorSlots = function (self, prof, sector)
		return 2
	end,
	GetTimelineEventDescription = function (self, sector_id, eventcontext)
		local mercs
		local professionId = self.Professions and self.Professions[1] and self.Professions[1].id
		if eventcontext.mercs then
			mercs = table.map(eventcontext.mercs, function(id) return gv_UnitData[id].Nick end)
		else
			mercs = GetOperationProfessionalsGroupedByProfession(sector_id, self.id)
			mercs = table.map(professionId and mercs[professionId] or mercs, "Nick")
		end
		mercs = ConcatListWithAnd(mercs)
		return T{177263993197, "<em><mercs></em> will finish repairing all items.", mercs = mercs}
	end,
	HasOperation = function (self, sector)
		return true
	end,
	IsEnabled = function (self, sector)
		local merc_ids=GetPlayerMercsInSector(sector.Id)
		local mercs = {}
		for _, id in ipairs(merc_ids) do
			mercs[#mercs+1] = gv_UnitData[id]
		end
		local to_repair= SectorOperationFillItemsToRepair(sector.Id,mercs,"checks")
		if not to_repair then
			return to_repair, T(348922386675, "No items that need repair")
		end
		return true
	end,
	OnRemoveOperation = function (self, merc)
		local sector = merc:GetSector()
		local mercs = GetOperationProfessionals(sector.Id, self.id,false, merc.session_id)
		-- reset items
		if #mercs<=0 then
			sector.sector_repair_items_queued = {}
			SectorOperationFillItemsToRepair(sector.Id,mercs)
			ObjModified(sector.sector_repair_items_queued)
			if sector.started_operations and sector.started_operations.RepairItems then
				NetSyncEvent("InterruptSectorOperation", sector.Id,"RepairItems")				
			end
			
			Msg("OperationCompleted", self, mercs, sector)
		end
	end,
	OnSetOperation = function (self, merc, arg)
		local sector = merc:GetSector()
		local mercs = GetOperationProfessionals(sector.Id, self.id)
		-- reset items
		sector.sector_repair_items_queued = {}
		SectorOperationFillItemsToRepair(sector.Id,mercs)
		ObjModified(sector.sector_repair_items_queued)
	end,
	Parameters = {
		PlaceObj('PresetParamNumber', {
			'Name', "restore_condition_per_Part",
			'Value', 20,
			'Tag', "<restore_condition_per_Part>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "free_repair",
			'Value', 20,
			'Tag', "<free_repair>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "min_time",
			'Value', 6,
			'Tag', "<min_time>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "parts_per_step",
			'Value', 1,
			'Tag', "<parts_per_step>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "stat_multiplier",
			'Value', 200,
			'Tag', "<stat_multiplier>",
		}),
	},
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "Repair",
			'display_name', T(943887686252, --[[SectorOperation RepairItems display_name]] "Mechanic"),
			'description', T(912139557649, --[[SectorOperation RepairItems description]] "The Mechanic will repair the selected items."),
			'display_name_all_caps', T(896649403923, --[[SectorOperation RepairItems display_name_all_caps]] "MECHANICS"),
			'display_name_plural', T(439077504277, --[[SectorOperation RepairItems display_name_plural]] "Mechanic"),
			'display_name_plural_all_caps', T(770353356808, --[[SectorOperation RepairItems display_name_plural_all_caps]] "MECHANICS"),
		}),
	},
	ProgressCompleteThreshold = function (self, merc, sector, prediction)
		local item, data = SectorOperationItemToRepair(sector.Id, prediction)
		if not item then return 0 end
		local queue = SectorOperationItems_GetItemsQueue(sector.Id,"RepairItems")
		
		local max = 0
		for _, data in ipairs(queue) do
			local item = SectorOperationRepairItems_GetItemFromData(data)
			if item then
				local max_condition = item:GetMaxCondition()			
				max = max + max_condition*item.RepairCost
			end
		end
		return max
	end,
	ProgressCurrent = function (self, merc, sector, prediction)
		local item, dta = SectorOperationItemToRepair(sector.Id, prediction)
		if not item then return 0 end
		local queue = SectorOperationItems_GetItemsQueue(sector.Id, "RepairItems")
		local max = 0
		for _, data in ipairs(queue) do
			local item =  SectorOperationRepairItems_GetItemFromData(data)
			local prev_cond = item.Condition
			max = max + prev_cond*item.RepairCost + item.repair_progress
			if not prediction then
				NetUpdateHash("RepairItem_ProgressCurrent", item.id, item.class, item.Condition, item.repair_progress)
			end
		end
		return max
	end,
	ProgressPerTick = function (self, merc, prediction)
		if not merc then return 0 end
		local sector = merc:GetSector()
		local mercs = GetOperationProfessionals(sector.Id, self.id)
		table.insert_unique(mercs, merc)
		
		local item, data = SectorOperationItemToRepair(sector.Id, prediction)
		if not item then
			return 0
		end
		-- add progress
		local sum_stat = GetSumOperationStats(mercs, "Mechanical", self:ResolveValue("stat_multiplier"))			
		return  sum_stat
	end,
	RequiredResources = {
		"Parts",
	},
	SectorMercsTick = function (self, merc)
		local sector = merc:GetSector()
		local start_time = sector.started_operations[self.id]
		local min_time = self:ResolveValue("min_time")
		local timediff =  (Game.CampaignTime - start_time)
		local min_h = (min_time*const.Scale.h)
		local ticks_left = 1 
		if timediff<min_h then
			-- does not progress first 6 (min_time) hours
			 return	
		elseif timediff==min_h then
			-- add all progress for the first 6(min_time) hours
			ticks_left = min_time*4
		end
		
		local mercs = GetOperationProfessionals(sector.Id, self.id)
		table.insert_unique(mercs, merc)
		
		for i=1,ticks_left do
			local item, data = SectorOperationItemToRepair(sector.Id)
			if not item then
				self:Complete(sector)
				return
			end
			-- add progress
			local forgiving_mode = IsGameRuleActive("ForgivingMode")
			local sum_stat = GetSumOperationStats(mercs, "Mechanical", self:ResolveValue("stat_multiplier"))
			local prev_cond = item.Condition
			local prev_progress = item.repair_progress
			local max_condition = item:GetMaxCondition()
			local to_repair = max_condition - prev_cond
			AddScaledProgress(item, "repair_progress", "Condition", sum_stat,max_condition, item.RepairCost)
			
			local repaired = item.Condition - prev_cond
			
			--use parts
			if repaired > 0 then
				if to_repair <= self:ResolveValue("free_repair") then
				else
					-- get one part
					local border = 0
					while border<max_condition do
						border = border + self:ResolveValue("restore_condition_per_Part")
						if item.Condition<border then
							break
						end	
						if prev_cond<border and item.Condition>=border then
							-- pay parts
							local parts, m, mbag, slot_name
							for _, merc in ipairs(mercs) do
								parts = merc:GetItem("Parts")			
								if parts then
									m = merc			
									slot_name = merc:GetItemSlot(item)
									break
								else	
									local bag = merc.Squad and GetSquadBagInventory(merc.Squad)
									if bag then
										parts = bag:GetItem("Parts")
										if parts then
											mbag = bag
											slot_name = "Inventory"
										end	
										break
									end
								end
							end
							if parts then							
								parts.Amount = parts.Amount - self:ResolveValue("parts_per_step") 
								if parts.Amount<=0 then
									if m then
										m:RemoveItem(slot_name, parts)
										DoneObject(parts)
										ObjModified(m)
									end	
									if mbag then
										mbag:RemoveItem(slot_name,parts)
										DoneObject(parts)
										ObjModified(mbag)
									end
									parts = false
								end
								InventoryUIRespawn()
							else
								item.Condition = prev_cond
								item.repair_progress = prev_progress
								CombatLog("important", T{788054483744, "Not enough parts to continue <em><activity></em> Operation in sector <SectorName(sector)>.", sector = sector, activity = self.display_name})
								self:Complete(sector)
								gv_Sectors[sector.Id].sector_repair_items_queued = {}
								local queue = gv_Sectors[sector.Id].sector_repair_items_queued
								ObjModified(queue)
							end
							break
						end
					end
				end
			end
			-- unjam jammed weapon
			if item:IsWeapon() and item.jammed then
				item:RepairJammed(item.Condition, data and data.unit and gv_UnitData[data.unit])
			end
		end
	end,
	SortKey = 50,
	Tick = function (self, merc)
		return
	end,
	description = T(903422499354, --[[SectorOperation RepairItems description]] "Use mechanical parts to repair damaged equipment. High <em>Mechanical</em> stat will increase repair speed."),
	display_name = T(953309329006, --[[SectorOperation RepairItems display_name]] "Repair Items"),
	group = "Default",
	icon = "UI/SectorOperations/T_Icon_Activity_Repair",
	id = "RepairItems",
	image = "UI/Messages/Operations/repair_item",
	min_requirement_stat = "Mechanical",
	min_requirement_stat_value = 20,
	related_stat = "Mechanical",
	short_name = T(114668317582, --[[SectorOperation RepairItems short_name]] "Repair"),
	sub_title = T(873976932489, --[[SectorOperation RepairItems sub_title]] "Equipment needs repairs"),
})

PlaceObj('SectorOperation', {
	Custom = false,
	GetOperationCost = function (self, merc, profession, idx)
		return SectorOperations["CraftCommonBase"].GetOperationCost(self, merc,profession, idx)
	end,
	GetSectorSlots = function (self, prof, sector)
		return 1
	end,
	HasOperation = function (self, sector)
		return sector.RepairShop
	end,
	IsEnabled = function (self, sector)
		return SectorOperations["CraftCommonBase"].IsEnabled(self, sector)
	end,
	OnRemoveOperation = function (self, merc)
		SectorOperations["CraftCommonBase"].OnRemoveOperation(self, merc)
	end,
	OnSetOperation = function (self, merc, arg)
		SectorOperations["CraftCommonBase"].OnSetOperation(self, merc, arg)
	end,
	Parameters = {
		PlaceObj('PresetParamNumber', {
			'Name', "PerTickProgress",
			'Value', 250,
			'Tag', "<PerTickProgress>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "MoneyCostBase",
			'Value', 300,
			'Tag', "<MoneyCostBase>",
		}),
	},
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "Crafter",
			'display_name', T(156589356398, --[[SectorOperation CraftAmmo display_name]] "Crafter"),
			'display_name_all_caps', T(275729540863, --[[SectorOperation CraftAmmo display_name_all_caps]] "CRAFTER"),
			'display_name_plural', T(175076488599, --[[SectorOperation CraftAmmo display_name_plural]] "Crafters"),
			'display_name_plural_all_caps', T(270986184311, --[[SectorOperation CraftAmmo display_name_plural_all_caps]] "CRAFTERS"),
		}),
	},
	ProgressCompleteThreshold = function (self, merc, sector, prediction)
		return SectorOperations["CraftCommonBase"].ProgressCompleteThreshold(self, merc,sector, prediction)
	end,
	ProgressCurrent = function (self, merc, sector, prediction)
		return SectorOperations["CraftCommonBase"].ProgressCurrent(self, merc,sector, prediction)
	end,
	ProgressPerTick = function (self, merc, prediction)
		return SectorOperations["CraftCommonBase"].ProgressPerTick(self, merc, prediction)
	end,
	RequiredResources = {
		"Money",
		"Parts",
	},
	SectorOperationStats = function (self, sector, check_only)
		return SectorOperations["CraftCommonBase"].SectorOperationStats(self, sector, check_only)
	end,
	SortKey = 53,
	Tick = function (self, merc)
		return SectorOperations["CraftCommonBase"].Tick(self, merc)
	end,
	description = T(279115450630, --[[SectorOperation CraftAmmo description]] "Use mechanical Parts and other components to craft different types of ammo. High <em>Explosives</em> stat will increase crafting speed."),
	display_name = T(267678749125, --[[SectorOperation CraftAmmo display_name]] "Craft Ammo"),
	group = "Default",
	icon = "UI/SectorOperations/T_Icon_Activity_Craft_Ammo",
	id = "CraftAmmo",
	image = "UI/Messages/Operations/craft_ammo",
	min_requirement_stat = "Explosives",
	min_requirement_stat_value = 50,
	related_stat = "Explosives",
	short_name = T(149265431435, --[[SectorOperation CraftAmmo short_name]] "Craft"),
})

PlaceObj('SectorOperation', {
	Custom = false,
	GetOperationCost = function (self, merc, profession, idx)
		return SectorOperations["CraftCommonBase"].GetOperationCost(self, merc,profession, idx)
	end,
	GetSectorSlots = function (self, prof, sector)
		return 1
	end,
	HasOperation = function (self, sector)
		return sector.RepairShop
	end,
	IsEnabled = function (self, sector)
		return SectorOperations["CraftCommonBase"].IsEnabled(self, sector)
	end,
	OnRemoveOperation = function (self, merc)
		SectorOperations["CraftCommonBase"].OnRemoveOperation(self, merc)
	end,
	OnSetOperation = function (self, merc, arg)
		SectorOperations["CraftCommonBase"].OnSetOperation(self, merc, arg)
	end,
	Parameters = {
		PlaceObj('PresetParamNumber', {
			'Name', "PerTickProgress",
			'Value', 250,
			'Tag', "<PerTickProgress>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "MoneyCostBase",
			'Value', 300,
			'Tag', "<MoneyCostBase>",
		}),
	},
	Professions = {
		PlaceObj('SectorOperationProfession', {
			'id', "Crafter",
			'display_name', T(156589356398, --[[SectorOperation CraftExplosives display_name]] "Crafter"),
			'display_name_all_caps', T(275729540863, --[[SectorOperation CraftExplosives display_name_all_caps]] "CRAFTER"),
			'display_name_plural', T(175076488599, --[[SectorOperation CraftExplosives display_name_plural]] "Crafters"),
			'display_name_plural_all_caps', T(270986184311, --[[SectorOperation CraftExplosives display_name_plural_all_caps]] "CRAFTERS"),
		}),
	},
	ProgressCompleteThreshold = function (self, merc, sector, prediction)
		return SectorOperations["CraftCommonBase"].ProgressCompleteThreshold(self, merc,sector, prediction)
	end,
	ProgressCurrent = function (self, merc, sector, prediction)
		return SectorOperations["CraftCommonBase"].ProgressCurrent(self, merc,sector, prediction)
	end,
	ProgressPerTick = function (self, merc, prediction)
		return SectorOperations["CraftCommonBase"].ProgressPerTick(self, merc, prediction)
	end,
	RequiredResources = {
		"Money",
		"Parts",
	},
	SectorOperationStats = function (self, sector, check_only)
		return SectorOperations["CraftCommonBase"].SectorOperationStats(self, sector, check_only)
	end,
	SortKey = 56,
	Tick = function (self, merc)
		return SectorOperations["CraftCommonBase"].Tick(self, merc)
	end,
	description = T(941585881415, --[[SectorOperation CraftExplosives description]] "Use mechanical Parts and other components to craft different types of explosives. High <em>Explosives</em> stat will increase crafting speed."),
	display_name = T(499811578131, --[[SectorOperation CraftExplosives display_name]] "Craft Explosives"),
	group = "Default",
	icon = "UI/SectorOperations/T_Icon_Activity_Craft_Explosives",
	id = "CraftExplosives",
	image = "UI/Messages/Operations/craft_explosives",
	min_requirement_stat = "Explosives",
	min_requirement_stat_value = 50,
	related_stat = "Explosives",
	short_name = T(870674025719, --[[SectorOperation CraftExplosives short_name]] "Craft"),
})

PlaceObj('SectorOperation', {
	Custom = false,
	GetOperationCost = function (self, merc, profession, idx)
		local sector = merc:GetSector()
		local loyalty = sector and GetCityLoyalty(sector.City) or 100
		local money_cost = self:ResolveValue("MoneyCostBase")
		if HasPerk(merc, "Negotiator") then
			local discount = CharacterEffectDefs.Negotiator:ResolveValue("discountPercent")
			money_cost = money_cost - MulDivRound(money_cost, discount, 100)
		end
		if loyalty>50 then
			money_cost = money_cost -  MulDivRound(money_cost,(loyalty-50) , 100)	
		end
		return {[1] = {value = money_cost, resource = "Money"}}
	end,
	GetSectorSlots = function (self, prof, sector)
		return 1
	end,
	HasOperation = function (self, sector)
		return false
	end,
	IsEnabled = function (self, sector)
		local mercs_available = GetAvailableMercs(sector, self)
		local prof = self.Professions[1]
		local mercs_current = GetOperationProfessionals(sector.Id, self.id, prof.id)
		if #mercs_available == 0 and #mercs_current == 0 then	
			return false, T{776447291880, "No <name> available", name = prof.display_name}
		end
		
		return true
	end,
	OnRemoveOperation = function (self, merc)
		local sector = merc:GetSector()
		local qid = GetCraftOperationListsIds(self.id)
		sector[qid] = {}
		SectorOperationValidateItemsToCraft(sector.Id, self.id, merc)
		ObjModified(sector[qid])
		sector.custom_operations[self.id] = nil
		if sector.started_operations and sector.started_operations[self.id] then
			NetSyncEvent("InterruptSectorOperation", sector.Id,self.id)				
		end
		SectorOperation_UpdateOnStop(self,{merc}, sector)
	end,
	OnSetOperation = function (self, merc, arg)
		local sector = merc:GetSector()
		local qid = GetCraftOperationListsIds(self.id)
		sector[qid] = {}
		SectorOperationValidateItemsToCraft(sector.Id, self.id, merc)
		SectorOperation_CraftTotalTime(sector.Id, self.id)
		ObjModified(sector[qid] )
	end,
	Parameters = {
		PlaceObj('PresetParamNumber', {
			'Name', "PerTickProgress",
			'Value', 250,
			'Tag', "<PerTickProgress>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "MoneyCostBase",
			'Value', 300,
			'Tag', "<MoneyCostBase>",
		}),
	},
	ProgressCompleteThreshold = function (self, merc, sector, prediction)
		if not merc then
			local mercs = GetOperationProfessionals(sector.Id, self.id)
			merc = mercs[1]
		end
		if not merc then return 0 end
		local stat = merc[self.related_stat]
		local calced_time = sector.custom_operations and sector.custom_operations[self.id] and sector.custom_operations[self.id].total_time or 0
		return calced_time
	end,
	ProgressCurrent = function (self, merc, sector, prediction)
		return  sector.custom_operations and sector.custom_operations[self.id] and sector.custom_operations[self.id].progress or -1
	end,
	ProgressPerTick = function (self, merc, prediction)
		if not merc then
			local mercs = GetOperationProfessionals(sector.Id, self.id)
			merc = mercs[1]
		end
		if not merc then return 0 end
		local progressPerTick = self:ResolveValue("PerTickProgress")
		if merc and HasPerk(merc, "JackOfAllTrades") then
			local mod = CharacterEffectDefs.JackOfAllTrades:ResolveValue("activityDurationMod")
			progressPerTick = progressPerTick + MulDivRound(progressPerTick, mod, 100)
		end
		if CheatEnabled("FastActivity") then
			progressPerTick = progressPerTick*100
		end
		
		return progressPerTick
	end,
	RequiredResources = {
		"Money",
	},
	SectorOperationStats = function (self, sector, check_only)
		local lines = {}				
		if self.min_requirement_stat and self.min_requirement_stat_value then
			local prop = table.find_value(UnitPropertiesStats:GetProperties(), "id", self.min_requirement_stat)
			if check_only then return true end
			lines[#lines + 1] = {text = T{300232421689, "Min Required <name>", name = prop.name}, value = T{139355455984, "<min_requirement_stat_value>",self}}					
		end
		return lines
	end,
	SortKey = 60,
	Tick = function (self, merc)
		local sector = merc:GetSector()
		local progress_per_tick = self:ProgressPerTick(merc)
		sector.custom_operations = sector.custom_operations or {}
		sector.custom_operations[self.id] = sector.custom_operations[self.id] or {}
		local prev_progress = (sector.custom_operations[self.id].progress or 0)
		sector.custom_operations[self.id].progress = prev_progress + progress_per_tick
		local cur_progress = sector.custom_operations[self.id].progress
		local queue = SectorOperationItems_GetItemsQueue(sector.Id, self.id) 
		local item_data
		local rem_progress 
		repeat
			if next(queue) then
				item_data = queue[1]
			end
			if not item_data then	
				self:Complete(sector)
				return
			end
			local mercs = gv_Squads[merc.Squad].units
			local recipe = CraftOperationsRecipes[item_data.recipe]
			local cur = sector.custom_operations[self.id].item_id
			if not cur or cur~=item_data.item_id then
				sector.custom_operations[self.id].item_id = item_data.item_id
				sector.custom_operations[self.id].item_id_start = rem_progress and rem_progress>0 and rem_progress or prev_progress
				rem_progress = 0
				-- get items
				for _, ingrd in ipairs(recipe.Ingredients) do
					--local result, results = InventoryFindItemInMercs(mercs, ingrd.item, ingrd.amount)
					local rem = TakeItemFromMercs(mercs, ingrd.item, ingrd.amount)
					if rem>0 then
						sector.custom_operations[self.id].item_id = false
						sector.custom_operations[self.id].item_id_start = 0
						CombatLog("important", T{788054483744, "Not enough parts to continue <em><activity></em> Operation in sector <SectorName(sector)>.", sector = sector, activity = self.display_name})
						self:Complete(sector)
						merc:SetCurrentOperation("Idle")
						return
					end
				end
			end	
			local cur_item_time =  SectorOperation_CraftItemTime(sector.Id,self.id,item_data.recipe )	
			if sector.custom_operations[self.id].item_id_start and cur_progress>=sector.custom_operations[self.id].item_id_start + cur_item_time then
				local used_time = sector.custom_operations[self.id].item_id_start + cur_item_time
				sector.custom_operations[self.id].item_id_start = 0
				sector.custom_operations[self.id].item_id = false
				local item = PlaceInventoryItem(recipe.ResultItem.item)
				if IsKindOf(item,"InventoryStack") then
					item.Amount = recipe.ResultItem.amount
				end	
				local items =  {item}
				AddItemsToSquadBag(merc.Squad, items)
				for idx, m in ipairs(mercs) do
					if #items<=0 then break end
					local unit = gv_UnitData[m]
					unit:AddItemsToInventory(items)
				end
				-- update queue
				rem_progress = used_time
				local qid = GetCraftOperationListsIds(self.id)
				table.remove(gv_Sectors[sector.Id][qid], 1)			
		
				--SectorOperation_ItemsUpdateItemLists()
			end		
		until not next(queue) or (not rem_progress or rem_progress<=0)		
		self:CheckCompleted(merc, sector)
	end,
	group = "Default",
	icon = "UI/SectorOperations/T_Icon_Activity_Repair",
	id = "CraftCommonBase",
	image = "UI/Messages/Operations/craft_ammo",
	min_requirement_stat = "Explosives",
	min_requirement_stat_value = 50,
	related_stat = "Explosives",
})

PlaceObj('SectorOperation', {
	BoostProgress = function (self, perc, sector)
		-- nop
	end,
	CheckCompleted = function (self, merc, sector)
		if self:ProgressCurrent(merc, sector) >= self:ProgressCompleteThreshold(merc, sector) then
			self:Complete(merc)
		end
	end,
	Comment = "New mercs are placed here.",
	Complete = function (self, merc)
		if  merc then -- is actually the merc
			merc:SetMessengerOnline(true)
			HiredMercArrived( merc)
			Msg("OperationCompleted", self,  merc, merc:GetSector())
		end
	end,
	Custom = false,
	GetTimelineEventDescription = function (self, sector_id, eventcontext)
		return T(392158132768, "<em><Nick></em> will arrive in Grand Chien at <em><SectorName(sector)></em>.")
	end,
	HasOperation = function (self, sector)
		return false
	end,
	IsEnabled = function (self, sector)
		return true
	end,
	ModifyProgress = function (self, value, sector)
		merc.arriving_progress = value
	end,
	OnComplete = function (self, sector, mercs)
		-- todo
	end,
	OnSetOperation = function (self, merc, arg)
		merc.arriving_progress = 0
		merc:SetMessengerOnline(false)
	end,
	ProgressCompleteThreshold = function (self, merc, sector, prediction)
		return GetMercArrivalTime()
	end,
	ProgressCurrent = function (self, merc, sector)
		return merc and merc.arriving_progress or 0
	end,
	ProgressPerTick = function (self, merc, prediction)
		return const.Satellite.Tick
	end,
	SortKey = 7,
	Tick = function (self, merc)
		local sector = merc:GetSector()
		local progress_per_tick = self:ProgressPerTick(merc)
		if CheatEnabled("FastActivity") then
			progress_per_tick = progress_per_tick*100
		end
		merc.arriving_progress = merc.arriving_progress + progress_per_tick
		self:CheckCompleted(merc, sector)
	end,
	display_name = T(400897546839, --[[SectorOperation Arriving display_name]] "Arriving in Grand Chien"),
	group = "System Operations",
	icon = "UI/SectorOperations/T_Icon_Activity_Arriving",
	id = "Arriving",
})

PlaceObj('SectorOperation', {
	BoostProgress = function (self, perc, sector)
		-- nop
	end,
	CanPerformOperationBase = function (self, merc, profession)
		return
	end,
	CheckCompleted = function (self, merc, sector)
		if self:ProgressCurrent(merc, sector) >= self:ProgressCompleteThreshold(merc, sector) then
			self:Complete(merc)
		end
	end,
	Comment = "System operation for units moving on the map",
	Complete = function (self, sector)
		return
	end,
	Custom = false,
	GetAssignMessage = function (self, nameCombination, costTexts)
		return ""
	end,
	GetDescription = function (self, merc)
		local s = merc.Squad
		local squad = gv_Squads[s]
		local sector = squad.CurrentSector
		local destId = GetSquadFinalDestination(sector, squad.route)
		local destS = gv_Sectors[destId]
		return T{self.description, destination = destS and GetSectorName(destS)}
	end,
	HasOperation = function (self, sector)
		return false
	end,
	IsEnabled = function (self, sector)
		return true
	end,
	ModifyProgress = function (self, value, sector)
		merc.traveling_progress = value
	end,
	OnComplete = function (self, sector, mercs)
		-- todo
	end,
	OnRemoveOperation = function (self, merc)
		local squad = merc.Squad
		squad = squad and gv_Squads[squad]
		
		-- heal in easy mode or when on a boat
		if IsGameRuleActive("ForgivingMode") or IsSquadWaterTravelling(squad) then
			merc.wounds_being_treated = 0
		end
	end,
	OnSetOperation = function (self, merc, arg)
		merc.traveling_progress = 0
		
		local squad = merc.Squad
		squad = squad and gv_Squads[squad]
		
		-- heal in easy mode or when on a boat
		if IsGameRuleActive("ForgivingMode") or IsSquadWaterTravelling(squad) then
			merc.wounds_being_treated = arg or PatientGetWoundedStacks(merc)
		end
	end,
	Parameters = {
		PlaceObj('PresetParamNumber', {
			'Name', "HealPerTickBase",
			'Value', 10,
			'Tag', "<HealPerTickBase>",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "HealWoundThreshold",
			'Value', 1000,
			'Tag', "<HealWoundThreshold>",
		}),
	},
	ProgressCompleteThreshold = function (self, merc, sector, prediction)
		return merc.OperationInitialETA or GetOperationTimerInitialETA(merc) or 0
	end,
	ProgressCurrent = function (self, merc, sector, prediction)
		return merc and merc.traveling_progress or 0
	end,
	ProgressPerTick = function (self, merc, prediction)
		return const.Satellite.Tick
	end,
	SectorOperationStats = function (self, sector)
		return false, false
	end,
	ShowInCombatBadge = false,
	SortKey = 7,
	Tick = function (self, merc)
		local sector = merc:GetSector()
		
		local squad = merc.Squad
		squad = squad and gv_Squads[squad]
		
		-- heal in easy mode or when on a boat
		if IsGameRuleActive("ForgivingMode") or IsSquadWaterTravelling(squad) then
			UnitHealPerTick(merc,self:ResolveValue("HealPerTickBase"), self:ResolveValue("HealWoundThreshold"))
		end
		
		local progress_per_tick = self:ProgressPerTick(merc)
		if CheatEnabled("FastActivity") then
			progress_per_tick = progress_per_tick*100
		end
		merc.traveling_progress = merc.traveling_progress + progress_per_tick
		self:CheckCompleted(merc, sector)
	end,
	description = T(325242484538, --[[SectorOperation Traveling description]] "Traveling to <destination>"),
	display_name = T(574702887779, --[[SectorOperation Traveling display_name]] "Traveling"),
	group = "System Operations",
	icon = "UI/SectorOperations/T_Icon_Activity_Traveling",
	id = "Traveling",
	operation_type = set( "Healing" ),
})

