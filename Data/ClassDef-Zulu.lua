-- ========== GENERATED BY ClassDef Editor (Ctrl-Alt-F3) DO NOT EDIT MANUALLY! ==========

PlaceObj('ClassDef', {
	group = "Zulu",
	id = "AnimParams",
	PlaceObj('PropertyDefBool', {
		'id', "UseWeapons",
		'name', "Use Weapons",
		'help', "Use weapon animations while executing this behavior.",
	}),
	PlaceObj('PropertyDefBool', {
		'id', "Running",
		'help', "Controls the use of running or walking animations while executing this behavior.",
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetAnimParams",
		'code', function (self)
			if self.RestoreDefault then
				return {}
			else
				return {
					move_anim = not self.Running and "Walk" or "Run",
					weapon_anim_prefix = not self.UseWeapons and "civ_" or nil,
					idle_stance = self.IdleStance and self.IdleStance ~= "do not change" and self.IdleStance or nil, 
					idle_action = self.IdleAction and self.IdleAction ~= "do not change" and self.IdleAction or nil
				}
			end
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "OnEditorSetProperty",
		'params', "prop_id, old_value, ged",
		'code', function (self, prop_id, old_value, ged)
			if prop_id == "IdleStance" then
				local actions = GetIdleAnimStanceActions(self.UseWeapons, self.IdleStance)
				if not table.find(actions, self.IdleAction) then
					self:SetProperty("IdleAction", actions[1])
				end
			end
		end,
	}),
	PlaceObj('PropertyDefCombo', {
		'id', "IdleStance",
		'name', "Idle Stance",
		'help', "What to do with the idle stance",
		'default', "do not change",
		'items', function (self) return GetIdleAnimStances(self.UseWeapons) end,
	}),
	PlaceObj('PropertyDefCombo', {
		'id', "IdleAction",
		'name', "Idle Action",
		'help', "What to do with the idle action",
		'default', "do not change",
		'items', function (self) return GetIdleAnimStanceActions(self.UseWeapons, self.IdleStance) end,
	}),
	PlaceObj('PropertyDefBool', {
		'id', "RestoreDefault",
		'name', "Restore Default",
		'help', "Restore to default behavior",
	}),
})

PlaceObj('ClassDef', {
	group = "Zulu",
	id = "BanterLine",
	PlaceObj('PropertyDefText', {
		'id', "Annotation",
		'name', "Annotation",
		'help', 'Extra context for voice actors, e.g. "angry", "sad", etc.',
		'translate', false,
	}),
	PlaceObj('PropertyDefBool', {
		'id', "MultipleTexts",
	}),
	PlaceObj('PropertyDefCombo', {
		'id', "Character",
		'name', "Character",
		'no_edit', "expression",
		'no_edit_expression', function (self) return self.MultipleTexts end,
		'default', "any",
		'items', function (self) return GetTargetUnitCombo() end,
	}),
	PlaceObj('PropertyDefChoice', {
		'id', "AnimationStyle",
		'name', "Animation Style",
		'items', function (self) return GetIdleStyleCombo(g_Classes[self.Character] and g_Classes[self.Character].gender) end,
	}),
	PlaceObj('PropertyDefText', {
		'id', "Text",
		'no_edit', "expression",
		'no_edit_expression', function (self) return self.MultipleTexts end,
		'wordwrap', true,
		'lines', 4,
		'max_lines', 6,
		'context', "BanterLineContext()",
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "AnyOfTheseCount",
		'name', "Play Any Of List Count",
		'no_edit', "expression",
		'no_edit_expression', function (self) return not self.MultipleTexts end,
		'default', 1,
	}),
	PlaceObj('PropertyDefNestedList', {
		'id', "AnyOfThese",
		'name', "Play Any Of List",
		'no_edit', "expression",
		'no_edit_expression', function (self) return not self.MultipleTexts end,
		'base_class', "BanterLineThin",
	}),
	PlaceObj('PropertyDefBool', {
		'id', "Voiced",
		'help', "Whether the banter is voiced.",
		'default', true,
	}),
	PlaceObj('PropertyDefBool', {
		'id', "useSnype",
		'name', "Use Snype",
		'help', "The banter will appear as a UI element on Snype rather than above the character's model.",
	}),
	PlaceObj('PropertyDefBool', {
		'id', "asVR",
		'name', "As VR",
		'help', "The banter will appear as a subtitled VR.",
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetPropertyMetadata",
		'params', "prop",
		'code', function (self, prop)
			local prop_meta = PropertyObject.GetPropertyMetadata(self, prop)
			
			--Hide the "voiced T" context when the banter line isn't voiced
			if prop == "Text" and not self.Voiced then
				prop_meta = SubContext(prop_meta, { context = false })
			end
			
			return prop_meta
		end,
	}),
	PlaceObj('PropertyDefBool', {
		'id', "Optional",
		'name', "Optional",
		'help', "Optional lines don't report missing actors and include actors around the source regardless of whether were passed in.",
		'no_edit', "expression",
		'no_edit_expression', function (self) return self.MultipleTexts end,
	}),
	PlaceObj('PropertyDefBool', {
		'id', "FloatUp",
		'name', "FloatUp",
		'help', "Float up like floating text, rather than staying in place like banter text.",
	}),
	PlaceObj('PropertyDefBool', {
		'id', "playOnce",
		'name', "Once Per Actor",
		'help', "This line will be played only once per unit. If optional this line will be skipped. In banters with no other lines, or if the other lines are disabled, the whole banter will be skipped by the PlayBanterEffect.",
	}),
	PlaceObj('PropertyDefButtons', {
		'id', "btnTestLine",
		'buttons', {
			PlaceObj('PropertyDefPropButton', {
				'Name', "Test Line",
				'FuncName', "EditorTestBanterLine",
			}),
		},
		'template', true,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetWarning",
		'code', function (self)
			if not self.Text and not self.AnyOfThese then
				return "Banter line without text!"
			end
			if self.Voiced then
				if self.MultipleTexts then
					for _, line in ipairs(self.AnyOfThese) do
						if g_AnyUnitGroups[line.Character] then
							return string.format("Banters for '%s' character can't be voiced", line.Character)	
						end
					end
				else
					if g_AnyUnitGroups[self.Character] then
						return string.format("Banters for '%s' character can't be voiced", self.Character)	
					end
				end
			end
			if self.Character == "current unit" then
				return "Current unit is not supported as a banter actor"
			end
			if not self.MultipleTexts and next(self.AnyOfThese) then
				return "Hidden lines in property Play Any Of These won't be played - check MultipleTexts to see (and delete) them"
			end
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetEditorView",
		'code', function (self)
			if self.MultipleTexts then
				local toPlay = self.AnyOfTheseCount
				local total = #(self.AnyOfThese or empty_table)
				
				local chars = {}
				for i, line in ipairs(self.AnyOfThese) do
					chars[#chars + 1] = Untranslated(line.Character)
				end
				chars = table.concat(chars, ", ")
				
				return T{595004298903, "Play <toPlay> of <total> lines. <chars>", toPlay = toPlay, total = total, chars = chars}
			end
			
			if not self.Text then return Untranslated("No Text") end
			
			local text = _InternalTranslate(self.Text)
			local long = #text > 50
			text = text:gsub('%\n', '')
			text = utf8.sub(text, 1, 50)
			if long then text = text .. "..." end
			
			return T{965627915065, "<u(Character)>: <u(Text)>", Character = self.Character, Text = text}
		end,
	}),
})

PlaceObj('ClassDef', {
	group = "Zulu",
	id = "BanterLineThin",
	PlaceObj('PropertyDefCombo', {
		'id', "Character",
		'name', "Character",
		'no_edit', "expression",
		'no_edit_expression', function (self) return self.IsInterjection end,
		'default', "any",
		'items', function (self) return GetTargetUnitCombo() end,
	}),
	PlaceObj('PropertyDefText', {
		'id', "Text",
		'no_edit', "expression",
		'no_edit_expression', function (self) return self.IsInterjection end,
		'wordwrap', true,
		'lines', 4,
		'max_lines', 6,
		'context', "BanterLineThinContext()",
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetWarning",
		'code', function (self)
			if not self.Text then
				return "Banter line without text!"
			end
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetEditorView",
		'code', function (self)
			if not self.Text then return Untranslated("No Text") end
			
			local text = _InternalTranslate(self.Text)
			local long = #text > 50
			text = text:gsub('%\n', '')
			text = utf8.sub(text, 1, 50)
			if long then text = text .. "..." end
			
			return T{965627915065, "<u(Character)>: <u(Text)>", Character = self.Character, Text = text}
		end,
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"DecorStateFXObjectNoSound",
	},
	group = "Zulu",
	id = "Butterflies",
	PlaceObj('PropertyDefGameStatefSet', {
		'category', "DecorStateFXObject",
		'id', "ActivationRequiredStates",
		'name', "States Required for Activation",
		'default', set({
	Night = false,
	RainHeavy = false,
	RainLight = false,
}),
	}),
	PlaceObj('ClassConstDef', {
		'name', "Preset",
		'type', "text",
		'value', "Butterflies_Blue",
	}),
	PlaceObj('ClassConstDef', {
		'name', "particles_pattern",
		'type', "text",
		'value', "Butterflies",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_category",
		'type', "text",
		'value', "Effects",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_name",
		'type', "text",
		'value', "DecorFX_Butterflies",
	}),
})

PlaceObj('ClassDef', {
	group = "Zulu",
	id = "CharacterEffectProperties",
	PlaceObj('PropertyDefNestedList', {
		'category', "Conditions",
		'id', "Conditions",
		'help', "Conditions specifying whether or not the effect can be applied to a given unit at the moment.",
		'template', true,
		'base_class', "Condition",
		'inclusive', true,
	}),
	PlaceObj('PropertyDefNestedList', {
		'category', "Modifiers",
		'id', "Modifiers",
		'help', "Numerical modifiers applied by the Status Effect to the affected Unit.",
		'template', true,
		'base_class', "UnitModifier",
	}),
	PlaceObj('PropertyDefText', {
		'id', "DisplayName",
		'template', true,
	}),
	PlaceObj('PropertyDefText', {
		'id', "Description",
		'template', true,
		'wordwrap', true,
		'lines', 4,
		'max_lines', 10,
	}),
	PlaceObj('PropertyDefFunc', {
		'id', "GetDescription",
		'template', true,
		'default', function (self)
			return self.Description
		end,
	}),
	PlaceObj('PropertyDefText', {
		'id', "AddEffectText",
		'help', "The merc object will be passed as context, use proper tags",
		'template', true,
	}),
	PlaceObj('PropertyDefText', {
		'id', "RemoveEffectText",
		'help', "The merc object will be passed as context, use proper tags",
		'template', true,
	}),
	PlaceObj('PropertyDefCombo', {
		'category', "Effect",
		'id', "type",
		'name', "Type",
		'help', '"System" effects are not either Positive or Negative for the sake of other features interacting with only Positive or Negative effects.\n"Buff" - something Positive\n"Debuff" - something Negative',
		'template', true,
		'default', "System",
		'items', function (self) return {"System", "Buff", "Debuff", "AttackBased"} end,
	}),
	PlaceObj('PropertyDefChoice', {
		'category', "Effect",
		'id', "lifetime",
		'name', "Lifetime",
		'template', true,
		'default', "Indefinite",
		'items', function (self) return { "Indefinite", "Until End of Turn", "Until End of Next Turn" } end,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Effect",
		'id', "CampaignTimeAdded",
		'read_only', true,
		'no_edit', true,
		'template', true,
		'default', 0,
	}),
	PlaceObj('PropertyDefUIImage', {
		'id', "Icon",
		'template', true,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Effect",
		'id', "max_stacks",
		'template', true,
		'default', 1,
		'min', 1,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Effect",
		'id', "stacks",
		'read_only', true,
		'no_edit', true,
		'template', true,
		'default', 1,
		'min', 1,
	}),
	PlaceObj('PropertyDefBool', {
		'category', "Effect",
		'id', "RemoveOnEndCombat",
		'name', "Auto-remove on combat end",
		'template', true,
	}),
	PlaceObj('PropertyDefBool', {
		'category', "Effect",
		'id', "RemoveOnSatViewTravel",
		'name', "Auto-remove on Satellite View Travel",
		'template', true,
	}),
	PlaceObj('PropertyDefBool', {
		'category', "Effect",
		'id', "RemoveOnCampaignTimeAdvance",
		'name', "Auto-remove on Campaign Time Advance",
		'help', "For map only effects",
		'template', true,
	}),
	PlaceObj('PropertyDefBool', {
		'category', "Effect",
		'id', "dontRemoveOnDeath",
		'name', "Don't Remove On Death",
		'template', true,
	}),
	PlaceObj('PropertyDefNestedList', {
		'id', "InstParameters",
		'base_class', "PresetParam",
	}),
	PlaceObj('PropertyDefBool', {
		'id', "HasParameters",
		'read_only', true,
		'no_edit', true,
		'default', true,
	}),
	PlaceObj('PropertyDefBool', {
		'id', "Shown",
		'help', "Whether the status effect is shown in the UI or it is for internal use only.",
		'template', true,
	}),
	PlaceObj('PropertyDefBool', {
		'id', "ShownSatelliteView",
		'help', "Whether the status effect is shown in the satellite view UI",
		'template', true,
	}),
	PlaceObj('PropertyDefBool', {
		'id', "HideOnBadge",
		'name', "HideOnBadge",
		'help', "Whether the status effect is hidden on the combat badge, beneath the healthbar.",
		'template', true,
	}),
	PlaceObj('PropertyDefBool', {
		'id', "HasFloatingText",
		'help', "Whether the status effects shows floating text when it is added or removed.",
		'template', true,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "SetParameter",
		'params', "name, value",
		'code', function (self, name, value)
			self.InstParameters = self.InstParameters or {}
			for _, item in ipairs(self.InstParameters) do
				if item.Name == name then
					item.Value = value
					return
				end 
			end
			
			table.insert(self.InstParameters, {Name = name, Value = value})
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "ClonePropertyValue",
		'params', "value, prop_meta",
		'code', function (self, value, prop_meta)
			if prop_meta.id=="InstParameters" then
					local new_value = table.copy(value, "deep")
					return new_value
			end
			return PropertyObject.ClonePropertyValue(self, value, prop_meta)
		end,
	}),
})

PlaceObj('ClassDef', {
	Comment = "Creates inventory item from id or loottable (presumably multiple)",
	DefParentClassList = {
		"ConditionalSpawn",
	},
	group = "Zulu",
	id = "ConditionalLoot",
	PlaceObj('PropertyDefPresetId', {
		'category', "Spawn Object",
		'id', "ItemId",
		'name', "Inventory Item Id",
		'preset_class', "InventoryItemCompositeDef",
	}),
	PlaceObj('PropertyDefPresetId', {
		'category', "Spawn Object",
		'id', "LootTableId",
		'name', "Loot Table Id",
		'preset_class', "LootDef",
	}),
	PlaceObj('ClassMethodDef', {
		'name', "SpawnObjects",
		'params', "container",
		'code', function (self, container)
			if not rawget(self,"objects") then rawset(self, "objects", false) end
			
			-- Empty table is not allowed intentionally.
			if self.objects then return end
			self.objects = {}
			
			if self.ItemId and self.ItemId~="" then
				table.insert(self.objects, PlaceInventoryItem(self.ItemId))	
			end
			
			if self.LootTableId then
				local loot_tbl = LootDefs[self.LootTableId]
				if loot_tbl then
					local is_external_seed = (loot_tbl.loot == "cycle") or (loot_tbl.loot =="each then last")
					local init_seed = is_external_seed and GetQuestVar(container.QuestId, container.QuestSeedVariable)
					local seed = loot_tbl:GenerateLootSeed(init_seed)
					if is_external_seed then
						local quest = QuestGetState(container.QuestId or "")
						SetQuestVar(quest, container.QuestSeedVariable, seed)
					end
					loot_tbl:GenerateLoot(self, {}, seed, self.objects)
				end
			end
			
			if IsKindOf(container, "ItemContainer") then
				for _,o in ipairs(self.objects) do
					if not container:GetItemPos(o) then
						container:AddItem("Inventory", o)
					end	
				end
			end
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "DespawnObjects",
		'params', "container",
		'code', function (self, container)
			if not rawget(self,"objects") then rawset(self, "objects", false) end
			if not self.objects or not next(self.objects) then return end
			local is_container  =  IsKindOf(container, "ItemContainer") 
			
			for i, obj in ipairs(self.objects) do
				if is_container  then 
					container:RemoveItem("Inventory",obj)
				end
				DoneObject(obj)
			end
			table.clear(self.objects)
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetError",
		'code', function (self)
			if self.LootTableId and not LootDefs[self.LootTableId] then
			  return "Invalid LootTableId " .. self.LootTableId
			end
		end,
	}),
})

PlaceObj('ClassDef', {
	Comment = "Virtual class: evaluates conditions, calls spawn/despawn",
	DefParentClassList = {
		"InitDone",
	},
	group = "Zulu",
	id = "ConditionalSpawn",
	PlaceObj('PropertyDefNestedList', {
		'category', "Spawn Object",
		'id', "Spawn_Conditions",
		'name', "Spawn Conditions",
		'base_class', "Condition",
	}),
	PlaceObj('PropertyDefNestedList', {
		'category', "Spawn Object",
		'id', "Despawn_Conditions",
		'name', "Despawn Conditions",
		'base_class', "Condition",
	}),
	PlaceObj('ClassConstDef', {
		'name', "objects",
		'type', "prop_table",
	}),
	PlaceObj('ClassConstDef', {
		'name', "last_spawned_objects",
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetSpawnDespawnConditions",
		'params', "marker,spawn_once",
		'code', function (self, marker,spawn_once)
			local bSpawnCond = true
			local bDespawnCond = self.Despawn_Conditions and next(self.Despawn_Conditions)
			for _, cond in ipairs(self.Spawn_Conditions or empty_table) do
				bSpawnCond = cond:Evaluate(self) and bSpawnCond
				if not bSpawnCond then break end
			end
			for _, cond in ipairs(self.Despawn_Conditions or empty_table) do
				bDespawnCond = cond:Evaluate(self)  and bDespawnCond
				if not bDespawnCond then break end
			end
			
			return bSpawnCond, bDespawnCond
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "Update",
		'params', "marker,spawn_once",
		'code', function (self, marker,spawn_once)
			if ForceDisableSpawnEnemy(self) then
				return
			end
			local bSpawnCond, bDespawnCond = self:GetSpawnDespawnConditions()
			if IgnoreSpawnEnemyConditions(self) then
				self.Side = "enemy1"
			end
			if not rawget(self,"objects") then rawset(self, "objects", false) end
			if bSpawnCond and not bDespawnCond and (not self.objects or not next(self.objects)) and not (spawn_once and rawget(self,"last_spawned_objects")) then
				self:SpawnObjects(marker)
				self.last_spawned_objects = true
			end
			if bDespawnCond and self.objects  then
				self:DespawnObjects(marker)
			end
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "SpawnObjects",
	}),
	PlaceObj('ClassMethodDef', {
		'name', "DespawnObjects",
	}),
})

PlaceObj('ClassDef', {
	Comment = "Virtual class: Marker with conditional spawn",
	DefParentClassList = {
		"GridMarker",
		"ConditionalSpawn",
	},
	group = "Zulu",
	id = "ConditionalSpawnMarker",
	PlaceObj('ClassMethodDef', {
		'name', "Init",
		'code', function (self)
			self.editor_text_offset = point(0,0,5*guim/2+300)
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "SpawnObjects",
	}),
	PlaceObj('ClassMethodDef', {
		'name', "DespawnObjects",
	}),
	PlaceObj('ClassMethodDef', {
		'name', "EditorGetText",
		'code', function (self)
			return  self.class
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "EditorEnter",
		'code', function (self)
			GridMarker.EditorEnter(self)
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "EditorExit",
		'code', function (self)
			GridMarker.EditorExit(self)
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetExtraEditorText",
		'params', "texts",
		'code', function (self, texts)
			for _, condition in ipairs(self.Spawn_Conditions or empty_table) do
				texts[#texts+1] = "\t\t " .. Untranslated( "spawn: ") .. T{condition:GetEditorView(), condition}
			end
			for _, condition in ipairs(self.Despawn_Conditions or empty_table) do
				texts[#texts+1] = "\t\t " .. Untranslated( "despawn: ") .. T{condition:GetEditorView(), condition}
			end
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetDynamicData",
		'params', "data",
		'code', function (self, data)
			data.last_spawned_objects = self.last_spawned_objects or nil
			data.objects = self.objects and true or nil
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "SetDynamicData",
		'params', "data",
		'code', function (self, data)
			self.last_spawned_objects = data.last_spawned_objects or false
		end,
	}),
	PlaceObj('PropertyDefText', {
		'id', "EditorRolloverText",
		'name', "EditorRolloverText",
		'dont_save', true,
		'read_only', true,
		'no_edit', true,
		'default', "Sets objects in collection visible.",
		'translate', false,
	}),
	PlaceObj('PropertyDefText', {
		'id', "EditorIcon",
		'name', "EditorIcon",
		'dont_save', true,
		'read_only', true,
		'no_edit', true,
		'default', "CommonAssets/UI/Icons/school",
		'translate', false,
	}),
})

PlaceObj('ClassDef', {
	Comment = "Manages two things: a collection of visible objects, visual representation of a container in the world and a logical container",
	DefParentClassList = {
		"ShowHideCollectionMarker",
		"ItemContainer",
	},
	group = "Zulu",
	id = "ContainerMarker",
	PlaceObj('PropertyDefNestedList', {
		'category', "Spawn Object",
		'id', "ItemSpawners",
		'name', "ItemSpawners",
		'base_class', "ConditionalLoot",
		'inclusive', true,
	}),
	PlaceObj('PropertyDefBool', {
		'category', "Spawn Object",
		'id', "HideIfEmpty",
		'name', "HideIfEmpty",
		'help', "If the holder is empty the marker becomes uninteractable.",
		'default', true,
	}),
	PlaceObj('PropertyDefBool', {
		'category', "Spawn Object",
		'id', "DespawnIfEmpty",
		'name', "DespawnIfEmpty",
		'help', "If the holder is empty the marker objects despawn.",
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "AreaHeight",
		'name', "Area Height",
		'read_only', true,
		'no_edit', true,
		'default', 0,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "AreaWidth",
		'name', "Area Width",
		'read_only', true,
		'no_edit', true,
		'default', 0,
	}),
	PlaceObj('PropertyDefText', {
		'id', "Type",
		'name', "Type",
		'read_only', true,
		'no_edit', true,
		'default', "InventoryItemSpawn",
		'translate', false,
	}),
	PlaceObj('PropertyDefText', {
		'id', "entity",
		'name', "entity",
		'read_only', true,
		'no_edit', true,
		'default', "WayPoint",
		'translate', false,
	}),
	PlaceObj('PropertyDefText', {
		'category', "Spawn Object",
		'id', "DisplayName",
		'name', "Container Display Name",
		'no_edit', true,
		'default', T(499385555106, --[[ClassDef Zulu ContainerMarker default]] "Bag"),
	}),
	PlaceObj('PropertyDefCombo', {
		'category', "Spawn Object",
		'id', "Name",
		'name', "Display Name",
		'default', "Bag",
		'items', function (self) return GetContainerNamesCombo() end,
		'translate', true,
	}),
	PlaceObj('PropertyDefPresetId', {
		'category', "Spawn Object",
		'id', "QuestId",
		'name', "QuestId",
		'help', "Quest to check.",
		'preset_class', "QuestsDef",
		'preset_filter', function (preset, obj, prop_meta)
			return QuestHasVariable(preset, "QuestVarNum")
		end,
	}),
	PlaceObj('PropertyDefChoice', {
		'category', "Spawn Object",
		'id', "QuestSeedVariable",
		'name', "QuestSeedVariable",
		'help', "Quest variable to check.",
		'items', function (self) return GetQuestsVarsCombo(self.QuestId, "Num") end,
	}),
	PlaceObj('PropertyDefText', {
		'id', "EditorRolloverText",
		'name', "EditorRolloverText",
		'dont_save', true,
		'read_only', true,
		'no_edit', true,
		'default', "Spawn/despawn Inventory items using id or loot table",
		'translate', false,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "Init",
	}),
	PlaceObj('ClassMethodDef', {
		'name', "Update",
		'code', function (self)
			if self.DespawnIfEmpty and not self:GetItemInSlot("Inventory") and self.objects then
				self:DespawnObjects()
			end
			local spawn_once = self.Trigger == "once" 
			ShowHideCollectionMarker.Update(self)
			for _, spawner in ipairs(self.ItemSpawners)  do
				spawner:Update(self, spawn_once)
			end
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetInteractionCombatAction",
		'params', "unit",
		'code', function (self, unit)
			if self.HideIfEmpty and not self:GetItemInSlot("Inventory") then
				return false
			elseif self.Type == "IntelInventoryItemSpawn" and gv_CurrentSectorId and not gv_Sectors[gv_CurrentSectorId].intel_discovered then
				return false
			end
			if self:IsEmpty("Inventory") then
				local anyVisible
				local efVisible = const.efVisible
				for i, o in ipairs(self.objects) do
					if o:GetEnumFlags(efVisible) ~= 0 then
						anyVisible = true
						break
					end
				end
				if not anyVisible then
					return false
				end
			end
			return ItemContainer.GetInteractionCombatAction(self, unit)
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetDynamicData",
		'params', "data",
		'code', function (self, data)
			for idx, spawner in ipairs(self.ItemSpawners)  do
				data.spawners = data.spawners or {}
				data.spawners[idx] = data.spawners[idx] or {}
				if rawget(spawner,"last_spawned_objects") then
					data.spawners[idx].last_spawned_objects = spawner.last_spawned_objects
				end
			end
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "SetDynamicData",
		'params', "data",
		'code', function (self, data)
			if data.spawners then
				for idx, spawner in ipairs(self.ItemSpawners)  do
					spawner.last_spawned_objects = data.spawners[idx] and data.spawners[idx].last_spawned_objects
				end
			end
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "EndInteraction",
		'params', "unit",
		'code', function (self, unit)
			ItemContainer.EndInteraction(self, unit)
			self:Update()
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "OnEditorSetProperty",
		'params', "prop_id, old_value, ged",
		'code', function (self, prop_id, old_value, ged)
			if prop_id == "Name"then
				local preset =  Presets.ContainerNames.Default[self.Name] 
				if preset then
					self.DisplayName = preset.DisplayName
				else
					self.DisplayName = T( RandomLocId(),self.Name)
				end
			end
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "CheckDiscovered",
		'params', "unit",
		'code', function (self, unit)
			if not self:IsMarkerEnabled() then return end
			if not self:GetInteractionCombatAction(unit) then return end
			return BoobyTrappable.CheckDiscovered(self, unit)
		end,
	}),
	PlaceObj('ClassConstDef', {
		'name', "reserved_handles",
		'type', "number",
		'value', 1,
	}),
})

PlaceObj('ClassDef', {
	group = "Zulu",
	id = "DamagePredictable",
	PlaceObj('PropertyDefNumber', {
		'id', "PotentialDamage",
		'name', "Potential Damage",
		'help', "used to indicate predicted damage done by attacks",
		'dont_save', true,
		'read_only', true,
		'no_edit', true,
		'default', 0,
		'min', 0,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "PotentialDamageConditional",
		'name', "Potential Damage Conditional",
		'help', "used to indicate predicted damage done by attacks",
		'dont_save', true,
		'read_only', true,
		'no_edit', true,
		'default', 0,
		'min', 0,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "PotentialSecondaryConditional",
		'name', "Potential Secondary Conditional",
		'help', "used to indicate secondary conditional damage doen by attacks",
		'dont_save', true,
		'read_only', true,
		'no_edit', true,
		'default', 0,
		'min', 0,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "StealthKillChance",
		'name', "Stealth Kill Chance",
		'help', "used to indicate chance a unit is instant killed from stealth",
		'dont_save', true,
		'read_only', true,
		'no_edit', true,
		'default', -1,
		'min', -1,
	}),
	PlaceObj('PropertyDefText', {
		'id', "SmallPotentialDamageIcon",
		'name', "SmallPotentialDamageIcon",
		'help', "used to indicate meta-data about the PotentialDamage",
		'dont_save', true,
		'read_only', true,
		'no_edit', true,
	}),
	PlaceObj('PropertyDefText', {
		'id', "LargePotentialDamageIcon",
		'name', "LargePotentialDamageIcon",
		'dont_save', true,
		'read_only', true,
		'no_edit', true,
	}),
})

PlaceObj('PresetDef', {
	DefParentClassList = {
		"ListPreset",
	},
	group = "Zulu",
	id = "DebrisList",
	PlaceObj('PropertyDefNestedList', {
		'id', "debris_list",
		'name', "",
		'base_class', "DebrisWeight",
	}),
})

PlaceObj('ClassDef', {
	group = "Zulu",
	id = "EmailAttachment",
	PlaceObj('PropertyDefUIImage', {
		'id', "picture",
		'name', "Picture",
	}),
	PlaceObj('PropertyDefText', {
		'id', "name",
		'name', "Name",
	}),
	PlaceObj('PropertyDefText', {
		'id', "size",
		'name', "Size",
		'default', T(476205954303, --[[ClassDef Zulu EmailAttachment default]] "82kb"),
	}),
	PlaceObj('PropertyDefText', {
		'id', "resolution",
		'name', "Resolution",
		'default', T(485105911401, --[[ClassDef Zulu EmailAttachment default]] "800x420x24bpp"),
	}),
	PlaceObj('PropertyDefText', {
		'id', "scale",
		'name', "Scale",
		'default', T(215258410442, --[[ClassDef Zulu EmailAttachment default]] "100%"),
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"DecorStateFXObjectNoSound",
	},
	group = "Zulu",
	id = "FallingDust",
	PlaceObj('PropertyDefSet', {
		'category', "DecorStateFXObject",
		'id', "ActivationRequiredStates",
		'name', "States Required for Activation",
		'default', set({
	RainHeavy = false,
	RainLight = false,
}),
		'items', function (self) return GetGameStateFilter() end,
		'three_state', true,
	}),
	PlaceObj('ClassConstDef', {
		'name', "Preset",
		'type', "text",
		'value', "Falling_Dust",
	}),
	PlaceObj('ClassConstDef', {
		'name', "particles_pattern",
		'type', "text",
		'value', "Falling_Dust",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_category",
		'type', "text",
		'value', "Effects",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_name",
		'type', "text",
		'value', "DecorFX_Falling_Dust",
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"DecorStateFXObjectNoSound",
	},
	group = "Zulu",
	id = "Fire_1x1",
	PlaceObj('PropertyDefSet', {
		'category', "DecorStateFXObject",
		'id', "ActivationRequiredStates",
		'name', "States Required for Activation",
		'default', set({
	Night = true,
	RainHeavy = false,
	RainLight = false,
}),
		'items', function (self) return GetGameStateFilter() end,
		'three_state', true,
	}),
	PlaceObj('ClassConstDef', {
		'name', "Preset",
		'type', "text",
		'value', "Molotov_Fire_1x1_Smoldering",
	}),
	PlaceObj('ClassConstDef', {
		'name', "particles_pattern",
		'type', "text",
		'value', "Molotov_Fire_1x1_Smoldering",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_category",
		'type', "text",
		'value', "Effects",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_name",
		'type', "text",
		'value', "DecorFX_Fire_1x1",
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"DecorStateFXObjectNoSound",
	},
	group = "Zulu",
	id = "Fire_1x2",
	PlaceObj('PropertyDefSet', {
		'category', "DecorStateFXObject",
		'id', "ActivationRequiredStates",
		'name', "States Required for Activation",
		'default', set({
	Night = true,
	RainHeavy = false,
	RainLight = false,
}),
		'items', function (self) return GetGameStateFilter() end,
		'three_state', true,
	}),
	PlaceObj('ClassConstDef', {
		'name', "Preset",
		'type', "text",
		'value', "Env_Fire1x2",
	}),
	PlaceObj('ClassConstDef', {
		'name', "particles_pattern",
		'type', "text",
		'value', "Env_Fire1x2",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_category",
		'type', "text",
		'value', "Effects",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_name",
		'type', "text",
		'value', "DecorFX_Fire_1x2",
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"DecorStateFXObjectWithSound",
	},
	group = "Zulu",
	id = "Flies",
	PlaceObj('PropertyDefGameStatefSet', {
		'category', "DecorStateFXObject",
		'id', "ActivationRequiredStates",
		'name', "States Required for Activation",
		'default', set({
	Day = true,
	RainHeavy = false,
	RainLight = false,
}),
	}),
	PlaceObj('ClassConstDef', {
		'name', "Preset",
		'type', "text",
		'value', "Swarm_Flies",
	}),
	PlaceObj('ClassConstDef', {
		'name', "particles_pattern",
		'type', "text",
		'value', "Swarm_Flies",
	}),
	PlaceObj('ClassConstDef', {
		'name', "sounds_pattern",
		'type', "text",
		'value', "flies",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_category",
		'type', "text",
		'value', "Effects",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_name",
		'type', "text",
		'value', "DecorFX_Flies",
	}),
	PlaceObj('ClassMethodDef', {
		'name', "CheckUnderground",
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"DecorStateFXObjectWithSound",
	},
	group = "Zulu",
	id = "Flies_Big",
	PlaceObj('PropertyDefSet', {
		'category', "DecorStateFXObject",
		'id', "ActivationRequiredStates",
		'name', "States Required for Activation",
		'default', set({
	Day = true,
	RainHeavy = false,
	RainLight = false,
}),
		'items', function (self) return GetGameStateFilter() end,
		'three_state', true,
	}),
	PlaceObj('ClassConstDef', {
		'name', "Preset",
		'type', "text",
		'value', "Env_Flies_Big",
	}),
	PlaceObj('ClassConstDef', {
		'name', "particles_pattern",
		'type', "text",
		'value', "Env_Flies_Big",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_category",
		'type', "text",
		'value', "Effects",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_name",
		'type', "text",
		'value', "DecorFX_Flies_Big",
	}),
	PlaceObj('ClassMethodDef', {
		'name', "CheckUnderground",
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"DecorStateFXObjectNoSound",
	},
	group = "Zulu",
	id = "FlyingCattilSeeds",
	PlaceObj('PropertyDefSet', {
		'category', "DecorStateFXObject",
		'id', "ActivationRequiredStates",
		'name', "States Required for Activation",
		'default', set({
	Fog = false,
	RainHeavy = false,
	RainLight = false,
}),
		'items', function (self) return GetGameStateFilter() end,
		'three_state', true,
	}),
	PlaceObj('ClassConstDef', {
		'name', "Preset",
		'type', "text",
		'value', "Env_FlyingCattailSeeds",
	}),
	PlaceObj('ClassConstDef', {
		'name', "particles_pattern",
		'type', "text",
		'value', "Env_FlyingCattailSeeds",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_category",
		'type', "text",
		'value', "Effects",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_name",
		'type', "text",
		'value', "DecorFX_FlyingCattailSeeds",
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"DecorStateFXObjectNoSound",
	},
	group = "Zulu",
	id = "FlyingConfetti",
	PlaceObj('PropertyDefSet', {
		'category', "DecorStateFXObject",
		'id', "ActivationRequiredStates",
		'name', "States Required for Activation",
		'default', set({
	RainHeavy = false,
	RainLight = false,
}),
		'items', function (self) return GetGameStateFilter() end,
		'three_state', true,
	}),
	PlaceObj('ClassConstDef', {
		'name', "Preset",
		'type', "text",
		'value', "Env_FlyingConfetti",
	}),
	PlaceObj('ClassConstDef', {
		'name', "particles_pattern",
		'type', "text",
		'value', "Env_FlyingConfetti",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_category",
		'type', "text",
		'value', "Effects",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_name",
		'type', "text",
		'value', "DecorFX_FlyingConfetti",
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"DecorStateFXObjectNoSound",
	},
	group = "Zulu",
	id = "FlyingDust",
	PlaceObj('PropertyDefSet', {
		'category', "DecorStateFXObject",
		'id', "ActivationRequiredStates",
		'name', "States Required for Activation",
		'default', set( "DustStorm" ),
		'items', function (self) return GetGameStateFilter() end,
		'three_state', true,
	}),
	PlaceObj('ClassConstDef', {
		'name', "Preset",
		'type', "text",
		'value', "Env_FlyingDust",
	}),
	PlaceObj('ClassConstDef', {
		'name', "particles_pattern",
		'type', "text",
		'value', "Env_FlyingDust",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_category",
		'type', "text",
		'value', "Effects",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_name",
		'type', "text",
		'value', "DecorFX_FlyingDust",
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"DecorStateFXObjectNoSound",
	},
	group = "Zulu",
	id = "FlyingDustRoad",
	PlaceObj('PropertyDefSet', {
		'category', "DecorStateFXObject",
		'id', "ActivationRequiredStates",
		'name', "States Required for Activation",
		'default', set(),
		'items', function (self) return GetGameStateFilter() end,
		'three_state', true,
	}),
	PlaceObj('ClassConstDef', {
		'name', "Preset",
		'type', "text",
		'value', "Road_dust",
	}),
	PlaceObj('ClassConstDef', {
		'name', "particles_pattern",
		'type', "text",
		'value', "Road_dust",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_category",
		'type', "text",
		'value', "Effects",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_name",
		'type', "text",
		'value', "DecorFX_DustRoad",
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"DecorStateFXObjectNoSound",
	},
	group = "Zulu",
	id = "FlyingEmbers",
	PlaceObj('PropertyDefSet', {
		'category', "DecorStateFXObject",
		'id', "ActivationRequiredStates",
		'name', "States Required for Activation",
		'default', set({
	RainHeavy = false,
	RainLight = false,
}),
		'items', function (self) return GetGameStateFilter() end,
		'three_state', true,
	}),
	PlaceObj('ClassConstDef', {
		'name', "Preset",
		'type', "text",
		'value', "Env_FlyingEmbers",
	}),
	PlaceObj('ClassConstDef', {
		'name', "particles_pattern",
		'type', "text",
		'value', "Env_FlyingEmbers",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_category",
		'type', "text",
		'value', "Effects",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_name",
		'type', "text",
		'value', "DecorFX_FlyingEmbers",
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"DecorStateFXObjectNoSound",
	},
	group = "Zulu",
	id = "FlyingGrass",
	PlaceObj('PropertyDefSet', {
		'category', "DecorStateFXObject",
		'id', "ActivationRequiredStates",
		'name', "States Required for Activation",
		'default', set({
	RainHeavy = false,
	RainLight = false,
}),
		'items', function (self) return GetGameStateFilter() end,
		'three_state', true,
	}),
	PlaceObj('ClassConstDef', {
		'name', "Preset",
		'type', "text",
		'value', "Env_FlyingGrass",
	}),
	PlaceObj('ClassConstDef', {
		'name', "particles_pattern",
		'type', "text",
		'value', "Env_FlyingGrass",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_category",
		'type', "text",
		'value', "Effects",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_name",
		'type', "text",
		'value', "DecorFX_FlyingGrass",
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"DecorStateFXObjectNoSound",
	},
	group = "Zulu",
	id = "FlyingGrass_Tropical",
	PlaceObj('PropertyDefSet', {
		'category', "DecorStateFXObject",
		'id', "ActivationRequiredStates",
		'name', "States Required for Activation",
		'default', set({
	RainHeavy = false,
	RainLight = false,
}),
		'items', function (self) return GetGameStateFilter() end,
		'three_state', true,
	}),
	PlaceObj('ClassConstDef', {
		'name', "Preset",
		'type', "text",
		'value', "Env_FlyingGrass_Tropical",
	}),
	PlaceObj('ClassConstDef', {
		'name', "particles_pattern",
		'type', "text",
		'value', "Env_FlyingGrass_Tropical",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_category",
		'type', "text",
		'value', "Effects",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_name",
		'type', "text",
		'value', "DecorFX_FlyingGrassTropical",
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"DecorStateFXObjectNoSound",
	},
	group = "Zulu",
	id = "FlyingMoney",
	PlaceObj('PropertyDefSet', {
		'category', "DecorStateFXObject",
		'id', "ActivationRequiredStates",
		'name', "States Required for Activation",
		'default', set({
	RainHeavy = false,
	RainLight = false,
}),
		'items', function (self) return GetGameStateFilter() end,
		'three_state', true,
	}),
	PlaceObj('ClassConstDef', {
		'name', "Preset",
		'type', "text",
		'value', "Env_FlyingMoney",
	}),
	PlaceObj('ClassConstDef', {
		'name', "particles_pattern",
		'type', "text",
		'value', "Env_FlyingMoney",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_category",
		'type', "text",
		'value', "Effects",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_name",
		'type', "text",
		'value', "DecorFX_FlyingMoney",
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"DecorStateFXObjectNoSound",
	},
	group = "Zulu",
	id = "FlyingPetals",
	PlaceObj('PropertyDefSet', {
		'category', "DecorStateFXObject",
		'id', "ActivationRequiredStates",
		'name', "States Required for Activation",
		'default', set({
	RainHeavy = false,
	RainLight = false,
}),
		'items', function (self) return GetGameStateFilter() end,
		'three_state', true,
	}),
	PlaceObj('ClassConstDef', {
		'name', "Preset",
		'type', "text",
		'value', "Env_FlyingPetals",
	}),
	PlaceObj('ClassConstDef', {
		'name', "particles_pattern",
		'type', "text",
		'value', "Env_FlyingPetals",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_category",
		'type', "text",
		'value', "Effects",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_name",
		'type', "text",
		'value', "DecorFX_FlyingPetals",
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"CommonGameSettings",
	},
	group = "Zulu",
	id = "GameSettings",
	PlaceObj('PropertyDefPresetId', {
		'id', "Campaign",
		'name', "Campaign",
		'preset_class', "CampaignPreset",
		'default', "HotDiamonds",
	}),
	PlaceObj('PropertyDefText', {
		'id', "playthrough_name",
		'name', "Playthrough Name",
		'lines', 1,
		'max_lines', 1,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "playthrough_time",
		'name', "Playthrough time",
		'default', 0,
		'min', 0,
	}),
	PlaceObj('PropertyDefBool', {
		'id', "isDev",
		'name', "IsDev",
		'help', "Used to flag new playthroughs as developer ones",
	}),
})

PlaceObj('PresetDef', {
	DefParentClassList = {
		"ListPreset",
	},
	group = "Zulu",
	id = "GridMarkerType",
	PlaceObj('PropertyDefText', {
		'id', "Name",
	}),
	PlaceObj('PropertyDefColor', {
		'id', "Color",
	}),
	PlaceObj('PropertyDefCombo', {
		'id', "Entity",
		'items', function (self) return table.keys2(GetAllEntities(), true) end,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "Scale",
		'default', 100,
		'min', 1,
		'max', 2047,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "AreaWidth",
		'default', 1,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "AreaHeight",
		'default', 1,
	}),
	PlaceObj('PropertyDefText', {
		'id', "MarkerGroup",
		'name', "Default Group",
		'help', "Add markers to this group by default",
		'translate', false,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "AreaThickness",
		'name', "AreaThickness",
		'default', 240,
		'min', 1,
		'max', 1000,
	}),
	PlaceObj('PropertyDefBool', {
		'id', "DefenderRole",
		'name', "Defender Role",
		'help', "Is marker used for placing defender units",
	}),
})

PlaceObj('ClassDef', {
	group = "Zulu",
	id = "MercChatBranch",
	PlaceObj('PropertyDefNestedList', {
		'id', "Lines",
		'name', "Lines",
		'extra_code', "sort_order = 100",
		'base_class', "ChatMessage",
	}),
	PlaceObj('PropertyDefNestedList', {
		'id', "Conditions",
		'name', "Conditions",
		'extra_code', "sort_order = 99",
		'base_class', "Condition",
	}),
	PlaceObj('PropertyDefFunc', {
		'id', "GetEditorView",
		'name', "GetEditorView",
		'no_edit', true,
		'default', function (self)
			local firstLine = self.Lines and self.Lines[1] and self.Lines[1].Text or ""
			local firstCond = self.Conditions and self.Conditions[1]
			firstCond = firstCond and _InternalTranslate(firstCond:GetEditorView(), firstCond) or ""
			return Untranslated(firstCond) .. " - " .. firstLine
		end,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "chanceToRoll",
		'name', "chanceToRoll",
		'default', 50,
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"MercChatBranch",
	},
	group = "Zulu",
	id = "MercChatHaggle",
	PlaceObj('ClassMethodDef', {
		'name', "RollRandom",
		'params', "mercId",
		'code', function (self, mercId)
			local dayHash = xxhash(mercId, (Game.CampaignTime / const.Scale.day) / 3, Game.id)
			local roll = 1 + BraidRandom(dayHash, 100)
			if const.DbgHiring then print("Haggle rolled " .. roll .. " / " .. self.chanceToRoll) end
			local successRollHaggle = roll < self.chanceToRoll
			if const.DbgHiring then
				if successRollHaggle then
					CombatLog("debug","haggle ocurred " .. roll .. " / " .. self.chanceToRoll)
				else
					CombatLog("debug","no haggle " .. roll .. " / " .. self.chanceToRoll)
				end
			end
			return successRollHaggle
		end,
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"MercChatBranch",
	},
	group = "Zulu",
	id = "MercChatMitigation",
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"MercChatBranch",
	},
	group = "Zulu",
	id = "MercChatRefusal",
	PlaceObj('PropertyDefChoice', {
		'id', "Type",
		'name', "Type",
		'default', "normal",
		'items', function (self) return { "normal", "duration", "rehire" } end,
	}),
	PlaceObj('PropertyDefChoice', {
		'id', "Duration",
		'name', "Duration",
		'extra_code', 'no_edit = function(self) return self.Type ~= "duration" end',
		'default', "short",
		'items', function (self) return { "short", "long" } end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "CustomBranchCondition",
		'params', "obj, ctx",
		'code', function (self, obj, ctx)
			if self.Type ~= "duration" then return true end
			local duration = ctx.ContractDuration or 0
			if self.Duration == "short" then
				return duration < 7
			elseif self.Duration == "long" then
				return duration >= 7
			end
			return true
		end,
	}),
})

PlaceObj('ClassDef', {
	group = "Zulu",
	id = "MishapProperties",
	PlaceObj('PropertyDefNumber', {
		'category', "Mishap",
		'id', "MinMishapChance",
		'help', "Mishap chance at 100 Explosives attribute",
		'template', true,
		'default', -8,
		'scale', "%",
		'modifiable', true,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Mishap",
		'id', "MaxMishapChance",
		'help', "Mishap chance at 0 Explosives attribute",
		'template', true,
		'default', 12,
		'scale', "%",
		'modifiable', true,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Mishap",
		'id', "MinMishapRange",
		'help', "Minimum range (in tiles) for the random target offest when a Mishap happens",
		'template', true,
		'default', 2,
		'modifiable', true,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Mishap",
		'id', "MaxMishapRange",
		'help', "Maximum range (in tiles) for the random target offest when a Mishap happens",
		'template', true,
		'default', 4,
		'modifiable', true,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetMishapChance",
		'params', "unit, target, async",
		'code', function (self, unit, target, async)
			local chance = self.MinMishapChance + MulDivRound(Max(0, 100 - unit.Explosives), Max(0, self.MaxMishapChance - self.MinMishapChance), 100)
			local item = IsKindOf(self, "FirearmBase") and self.parent_weapon or self
			local percent = 100
			if IsKindOf(item, "InventoryItem") then
				percent = item:GetConditionPercent()
				chance = Max(chance, 100 - percent)
			end 
			if GameState.RainHeavy  and IsKindOf(item, "GrenadeProperties") then
				chance = Clamp(MulDivRound(chance, const.EnvEffects.RainMishapMultiplier, 100), const.EnvEffects.RainMishapMinChance, const.EnvEffects.RainMishapMaxChance)
			end
			
			if not async then
				NetUpdateHash("GetMishapChance", unit, target, chance, unit.Explosives, percent, GameState.RainHeavy, self.MinMishapChance, self.MaxMishapChance)
			end
			
			return Max(0, chance)
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetMishapDeviationVector",
		'params', "unit, target",
		'code', function (self, unit, target)
			local deviation = unit:RandRange(self.MinMishapRange * const.SlabSizeX, self.MaxMishapRange * const.SlabSizeX)
			return Rotate(point(deviation, 0, 0), unit:Random(360*60))
		end,
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"DecorStateFXObjectNoSound",
	},
	group = "Zulu",
	id = "Mist",
	PlaceObj('PropertyDefSet', {
		'category', "DecorStateFXObject",
		'id', "ActivationRequiredStates",
		'name', "States Required for Activation",
		'default', set({
	RainHeavy = false,
}),
		'items', function (self) return GetGameStateFilter() end,
		'three_state', true,
	}),
	PlaceObj('ClassConstDef', {
		'name', "Preset",
		'type', "text",
		'value', "Ground_Mist",
	}),
	PlaceObj('ClassConstDef', {
		'name', "particles_pattern",
		'type', "text",
		'value', "Mist",
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "entity_scale",
		'name', "Entity Scale",
		'default', 10,
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_category",
		'type', "text",
		'value', "Effects",
	}),
})

PlaceObj('PresetDef', {
	DefGlobalMap = "MultiplayerGameFiltersList",
	DefParentClassList = {
		"ListPreset",
	},
	group = "Zulu",
	id = "MultiplayerGameFilters",
	PlaceObj('PropertyDefText', {
		'id', "Name",
	}),
})

PlaceObj('ClassDef', {
	group = "Zulu",
	id = "PerkProperties",
	PlaceObj('PropertyDefCombo', {
		'category', "Perk",
		'id', "Tier",
		'template', true,
		'default', "System",
		'items', function (self) return {"Bronze", "Silver", "Gold", "Personal", "Quirk", "Personality", "Specialization", "System"} end,
	}),
	PlaceObj('PropertyDefCombo', {
		'category', "Perk",
		'id', "Stat",
		'name', "Related Stat",
		'no_edit', "expression",
		'no_edit_expression', function (self) return not (self.Tier == "Bronze" or self.Tier == "Silver" or self.Tier == "Gold") end,
		'template', true,
		'items', function (self) return {"Health", "Agility", "Dexterity", "Strength", "Leadership", "Wisdom", "Marksmanship", "Mechanical", "Explosives", "Medical"} end,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Perk",
		'id', "StatValue",
		'name', "Stat Requirement",
		'no_edit', "expression",
		'no_edit_expression', function (self) return not (self.Tier == "Bronze" or self.Tier == "Silver" or self.Tier == "Gold") end,
		'template', true,
		'default', 30,
		'slider', true,
		'min', 0,
		'max', 100,
	}),
	PlaceObj('PropertyDefButtons', {
		'category', "Perk",
		'id', "StartingPerkOf",
		'name', "Starting Perk Of",
		'dont_save', true,
		'read_only', true,
		'template', true,
		'extra_code', "buttons = function(obj) return PersonalPerkStartingOfButtons(obj) end",
	}),
	PlaceObj('PropertyDefUIImage', {
		'id', "Icon",
		'template', true,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "IsLevelUp",
		'code', function (self)
			return self.Tier == "Bronze" or self.Tier == "Silver" or self.Tier == "Gold"
		end,
	}),
})

PlaceObj('ClassDef', {
	group = "Zulu",
	id = "RadioPlaylistTrack",
	PlaceObj('PropertyDefBrowse', {
		'id', "Track",
		'name', "Track",
		'default', "Music",
		'folder', "Music",
		'filter', "WAV files|*.wav",
		'extension', "",
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "Frequency",
		'name', "Weight",
		'default', 100,
	}),
	PlaceObj('PropertyDefBool', {
		'id', "EmptyTrack",
		'name', "Empty Track",
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "Duration",
		'name', "Duration",
		'extra_code', "no_edit = function(self) return not self.EmptyTrack end",
		'default', 5000,
		'scale', "sec",
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetError",
		'code', function (self)
			if not self.EmptyTrack then
				local path = string.format("%s.wav", self.Track)
				if not io.exists(path) then
					return string.format("Missing '%s'", path)
				end
			end
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetEditorView",
		'code', function (self)
			if self.EmptyTrack then
				return Untranslated("Empty Track (<u(Frequency)>) for <FormatScale(Duration, 'sec')>")
			else
				return Untranslated("<u(Track)> (<u(Frequency)>)")
			end
		end,
	}),
})

PlaceObj('ClassDef', {
	Comment = "Works on objects from collection, doesn't actually spawn anything, just shows/hides them",
	DefParentClassList = {
		"ConditionalSpawnMarker",
		"SaveMapCheckMarker",
	},
	group = "Zulu",
	id = "ShowHideCollectionMarker",
	PlaceObj('ClassMethodDef', {
		'name', "GameInit",
		'code', function (self)
			if not IsEditorActive() and not self.objects then
				self:HideObjects()
			end
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetObjects",
		'code', function (self)
			local root_collection = self:GetRootCollection()
			local collection_idx = root_collection and root_collection.Index or 0
			if collection_idx and collection_idx ~= 0 then
				return MapGet(self, self.CollectionRange, "collection", collection_idx, true, function(o)
					return not IsKindOf(o, "EditorMarker")
				end)
			end
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "HideObjects",
		'code', function (self)
			local objects = self.objects or self:GetObjects()
			local enumflags = self.restore_enumflags
			local efCollision = const.efCollision
			for i, o in ipairs(objects) do
				if IsValid(o) and o:GetVisible() then
					o:SetVisible(false)
					if o:GetCollision() then
						o:SetCollision(false)
						if not enumflags then
							enumflags = {}
						end
						enumflags[o] = efCollision
					end
				end
			end
			if enumflags then
				self.restore_enumflags = enumflags
			end
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "ShowObjects",
		'code', function (self)
			local objects = self.objects or self:GetObjects()
			local enumflags = self.restore_enumflags
			self.restore_enumflags = nil
			local efCollision = const.efCollision
			for i, o in ipairs(objects) do
				if IsValid(o) then
					o:SetVisible(true)
					if enumflags then
						local flags = enumflags[o]
						if flags and (flags & efCollision) ~= 0 then
							o:SetCollision(true)
						end
					end
				end
			end
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "SpawnObjects",
		'code', function (self)
			if self.objects then
				return
			elseif self.Trigger == "once" and self.last_spawned_objects then
				return
			end
			self.objects = self:GetObjects() or empty_table
			self:ShowObjects()
			local game_flags = self.sync_obj and const.gofSyncObject
			for i, o in ipairs(self.objects) do
				o.spawner = self
				if game_flags then
					o:SetGameFlags(game_flags)
				end
			end
			self.last_spawned_objects = true
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "DespawnObjects",
		'code', function (self)
			if not self.objects then return end
			for _, o in ipairs(self.objects) do
				o.spawner = nil
			end
			if not IsEditorActive() then
				self:HideObjects()
			end
			self.objects = nil
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "EditorEnter",
		'code', function (self)
			GridMarker.EditorEnter(self)
			self:ShowObjects()
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "EditorExit",
		'code', function (self)
			GridMarker.EditorExit(self)
			if not self.objects then
				self:HideObjects()
			end
			self:Update()
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetDynamicData",
		'params', "data",
		'code', function (self, data)
			data.objects = self.objects and true or nil
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "SetDynamicData",
		'params', "data",
		'code', function (self, data)
			if data.objects then
				self.objects = self:GetObjects() or empty_table
				self:ShowObjects()
				for i, o in ipairs(self.objects) do
					o.spawner = self
					if self.sync_obj then
						o:SetGameFlags(const.gofSyncObject)
					end
				end
			end
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetError",
		'code', function (self)
			if not Platform.developer then return end
			local collection_idx = self:GetCollectionIndex()
			if collection_idx and collection_idx ~= 0 then
				local outside_objects = MapGet("map", "collection", collection_idx, true, function(o, self)
					return not IsCloser2D(self, o, self.CollectionRange)
				end, self)
				if outside_objects then
					return string.format("'%s' too far from its '%s'(must be within %d", outside_objects[1]:GetEntity(), self.class, self.CollectionRange)
				end
				
				local nonEssentialObjects = MapGet("map", "collection", collection_idx, true, function(o, self)
					return o:GetDetailClass() ~= "Essential"
				end, self)
				if nonEssentialObjects then
					return "Objects in ShowHideCollectionMarker need to be marked as detail level: 'Essential'"
				end
			end
		end,
	}),
	PlaceObj('PropertyDefText', {
		'id', "EditorRolloverText",
		'name', "EditorRolloverText",
		'dont_save', true,
		'read_only', true,
		'no_edit', true,
		'default', "Sets objects in collection visible.",
		'translate', false,
	}),
	PlaceObj('PropertyDefText', {
		'id', "EditorIcon",
		'name', "EditorIcon",
		'dont_save', true,
		'read_only', true,
		'no_edit', true,
		'default', "CommonAssets/UI/Icons/school",
		'translate', false,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "CollectionRange",
		'name', "Collection Range",
		'help', "The range in which to gather objects from the collection, warns with VME if further than that",
		'default', 10000,
		'scale', "m",
	}),
	PlaceObj('PropertyDefBool', {
		'category', "Spawn Object",
		'id', "sync_obj",
		'name', "SyncObject",
		'help', "",
	}),
	PlaceObj('ClassConstDef', {
		'name', "restore_enumflags",
		'type', "prop_table",
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"DecorStateFXObjectNoSound",
	},
	group = "Zulu",
	id = "SunRays",
	PlaceObj('PropertyDefSet', {
		'category', "DecorStateFXObject",
		'id', "ActivationRequiredStates",
		'name', "States Required for Activation",
		'default', set({
	Night = false,
}),
		'items', function (self) return GetGameStateFilter() end,
		'three_state', true,
	}),
	PlaceObj('ClassConstDef', {
		'name', "Preset",
		'type', "text",
		'value', "Env_SunRays",
	}),
	PlaceObj('ClassConstDef', {
		'name', "particles_pattern",
		'type', "text",
		'value', "env_SunRays",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_category",
		'type', "text",
		'value', "Effects",
	}),
	PlaceObj('ClassConstDef', {
		'name', "place_name",
		'type', "text",
		'value', "DecorFX_SunRays",
	}),
})

PlaceObj('ClassDef', {
	group = "Zulu",
	id = "UnitDataSpawnData",
	PlaceObj('PropertyDefPresetId', {
		'id', "UnitDataDefId",
		'name', "UnitDataCompositeDef Id",
		'help', "Choose mercenary, enemy, or NPC from the Unit editor to spawn",
		'preset_class', "UnitDataCompositeDef",
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "SpawnWeight",
		'name', "Spawn Weight",
		'help', "Spawn a unit from one of several unit templates using a weighted average.",
		'default', 100,
		'min', 0,
	}),
	PlaceObj('PropertyDefPresetId', {
		'id', "ForcedAppearance",
		'name', "Forced Appearance",
		'help', "Force this template to use this appearance instead of randomly choosing from its own list of appearances",
		'preset_class', "AppearancePreset",
	}),
	PlaceObj('PropertyDefText', {
		'id', "Name",
		'name', "Name Override",
		'help', "Name for the spawned unit that will replace the one from template.",
		'template', true,
		'lines', 1,
		'max_lines', 1,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetEditorView",
		'code', function (self)
			return Untranslated("<UnitDataDefId> <Name> (weight: <SpawnWeight>) ")
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "OnEditorSetProperty",
		'params', "prop_id, old_value, ged",
		'code', function (self, prop_id, old_value, ged)
			local function set_appearance(obj)
				local first = obj:GetAppearenceTemplateId()
				local appearance = ChooseUnitAppearance(first)
				obj:ApplyAppearance(appearance)
				obj.Appearance = appearance
			end
			
			if prop_id=="UnitDataDefId" then
				local parent = ged.selected_object
				if parent:IsKindOf("GedMultiSelectAdapter") then
					for _, obj in ipairs(parent.__objects) do
						set_appearance(obj)
					end
				else
					set_appearance(parent)
				end
			end
		end,
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"ShowHideCollectionMarker",
		"AppearanceObject",
	},
	group = "Zulu",
	id = "UnitMarker",
	PlaceObj('PropertyDefNumber', {
		'id', "AreaHeight",
		'name', "Area Height",
		'default', 1,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "AreaWidth",
		'name', "Area Width",
		'default', 1,
	}),
	PlaceObj('PropertyDefText', {
		'category', "Spawn Object",
		'id', "Appearance",
		'name', "Appearance",
		'no_edit', true,
		'translate', false,
	}),
	PlaceObj('PropertyDefChoice', {
		'id', "anim",
		'name', "Animation",
		'no_edit', true,
		'no_validate', true,
		'default', "idle",
		'items', function (self) return ValidAnimationsCombo end,
	}),
	PlaceObj('PropertyDefBool', {
		'category', "Animation",
		'id', "use_weapons",
		'name', "Use weapons",
		'help', "Use weapon animations in idle state.",
		'default', true,
	}),
	PlaceObj('PropertyDefBool', {
		'category', "Spawn Object",
		'id', "Suspicious",
		'help', "Set spawned units to Suspicious state",
	}),
	PlaceObj('ClassMethodDef', {
		'name', "Init",
		'code', function (self)
			self.parts = {}
			self.attached_parts = { "Head", "Pants", "Shirt", "Armor", "Hat" }
			self.attach_spot = { ["Hat"] = "Head" }		-- "Origin" by default
			local first = self:GetAppearenceTemplateId()
			local appearance = self.Appearance or ChooseUnitAppearance(first, self.handle)
			self:ApplyAppearance(appearance)
			self.Appearance = appearance
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "SpawnObjects",
		'code', function (self)
			if not self.UnitDataSpawnDefs or #self.UnitDataSpawnDefs < 1 then 
				return
			end
			
			-- Empty table is not allowed intentionally to prevent respawning on
			-- deleted unit object as some markers are not setup as "once".
			if self.objects and not self.AlwaysSpawn then return end
			if self.Trigger == "once" and self.last_spawned_objects then return end
			
			local pts =  GetReachablePositionsFromPos(self:GetPos(), 1)
			
			-- prepare template & session ids
			local session_id, template_idx = self:GenerateUnitIds()
			
			if pts and #pts > 0 then
				local idx = template_idx
				local unit_template_id = self.UnitDataSpawnDefs[idx].UnitDataDefId
				local name = self.UnitDataSpawnDefs[idx].Name
				local pos = pts[1]
				
				-- check for existing UnitData for this session_id, if the unit has died skip the spawn
				local unit_data = gv_UnitData and gv_UnitData[session_id]
				if not (unit_data and unit_data:IsDead()) then
					-- If changing the template id of a unit we need to recreate the unit data.
					if unit_data and unit_data.class ~= unit_template_id then
						unit_data:delete()
						gv_UnitData[session_id] = false
					end
				
					pos:SetInvalidZ()
					local unit = SpawnUnit(unit_template_id,
						session_id,
						pos,
						self:GetAngle(),
						self.Groups,
						self)
						
					unit.sequential_banter = self.BantersSequential
					
					local approach_banters = {}
					table.iappend(approach_banters, self.ApproachedBanters)
					table.iappend(approach_banters, table.keys2(Presets.BanterDef[self.ApproachBanterGroup] or {}, "sorted"))
					unit.approach_banters = approach_banters
					unit.approach_banters_distance = self.ApproachRadius
					
					if name and name~="" then
						unit.Name = name
					end
					self.objects = { unit }
					ShowHideCollectionMarker.SpawnObjects(self)
					unit:SetSide(self.Side)
					unit.routine = self.Routine
					unit.routine_area = self.RoutineArea
					unit.routine_spawner = self
					unit.conflict_ignore = self.ConflictIgnore
					if self.Side == "neutral" and GameState.Conflict and unit:CanCower() then
						unit:TeleportToCower()
					end
					if self.kill_on_spawn then
						unit:SetCommand("Die")
					end
				end
			end
			
			if self.Persistent then
				self.unit_template_idx = template_idx
			end
			
			self.last_spawned_objects = true
			return self.objects
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "DespawnObjects",
		'code', function (self)
			if not self.objects or not next(self.objects) then return end
			for i = #self.objects,1,-1 do
				local obj = self.objects[i]
				if IsValid(obj) and IsKindOf(obj, "Unit") and obj:IsNPC() and (not obj:IsDead() or obj.PersistentSessionId) then
					obj.spawner = false
					DoneObject(obj)
					table.remove(self.objects, i)
				end	
			end
			ShowHideCollectionMarker.DespawnObjects(self)
			self.objects = false
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GenerateUnitIds",
		'code', function (self)
			local unit_template_idx, session_id
			if not self.Persistent or not self.unit_template_idx then
				-- weighted random
				local accum_weight = 0
				for i=1,#self.UnitDataSpawnDefs do
					accum_weight = accum_weight + self.UnitDataSpawnDefs[i].SpawnWeight
				end
				
				-- weighted random get rnd template
				local target_weight
				target_weight = InteractionRand(accum_weight, "spawn_objects", self)
				local sum_weight = 0
				for i=1,#self.UnitDataSpawnDefs-1 do
					sum_weight = sum_weight + self.UnitDataSpawnDefs[i].SpawnWeight
					if sum_weight > target_weight then
						unit_template_idx = i
						break
					end
				end
				unit_template_idx = unit_template_idx or #self.UnitDataSpawnDefs
			else
				unit_template_idx = self.unit_template_idx
			end
			
			local template = self.UnitDataSpawnDefs[unit_template_idx].UnitDataDefId
			template = template and UnitDataDefs[template]
			
			if template and (template.PersistentSessionId or "") ~= "" then
				session_id = template.PersistentSessionId
			elseif self.Persistent then
				session_id = self.SessionId
			else
				session_id = GenerateUniqueUnitDataId("SpawnerUnit", gv_CurrentSectorId, unit_template_idx)
			end
			
			return session_id, unit_template_idx
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetDynamicData",
		'params', "data",
		'code', function (self, data)
			data.last_spawned_objects = self.last_spawned_objects or nil
			if self.objects then
				data.objects = {}
				for _, obj in ipairs(self.objects) do
					table.insert(data.objects, obj:GetHandle())
				end
			end
			
			data.unit_template_idx = self.unit_template_idx or nil
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "SetDynamicData",
		'params', "data",
		'code', function (self, data)
			if data.objects then
				self.objects = {}
				for _, handle in ipairs(data.objects) do
					local obj = HandleToObject[handle]
					if obj then
						table.insert(self.objects, obj)
					end
				end
			end
			self.last_spawned_objects = data.last_spawned_objects or false
			self.unit_template_idx = data.unit_template_idx
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "EditorEnter",
		'code', function (self)
			ShowHideCollectionMarker.EditorEnter(self)
			local first = self:GetAppearenceTemplateId()
			local appearance = self.Appearance or ChooseUnitAppearance(first, self.handle)
			self:ApplyAppearance(appearance)
			self.Appearance = appearance
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "EditorGetText",
		'code', function (self)
			return self:GetAppearenceTemplateId() or self.class
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetExtraEditorText",
		'params', "texts",
		'code', function (self, texts)
			texts[#texts+1] = "\t\t " .. T{747690717505, "<Side>:",self}
			for _, temp_obj in ipairs(self.UnitDataSpawnDefs or empty_table) do
				texts[#texts+1] = "\t\t\t " .. T{925017903706, "<UnitDataDefId> <Name> (<SpawnWeight>)", temp_obj, Name = temp_obj.Name}
			end
			ShowHideCollectionMarker.GetExtraEditorText(self, texts)
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetAppearenceTemplateId",
		'code', function (self)
			local first =  self.UnitDataSpawnDefs and self.UnitDataSpawnDefs[1] 
			return first and first.UnitDataDefId
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetError",
		'code', function (self)
			if self.Persistent and (self.SessionId or "") == "" then
				return "Persistent units must have a valid Session ID"
			end
			
			local errors = {}
			local spawn_defs = self.UnitDataSpawnDefs
			for _, spawn_def in ipairs(spawn_defs or empty_table) do
				local unitdatadef_id = spawn_def.UnitDataDefId
				local unit_def = unitdatadef_id and UnitDataDefs[unitdatadef_id]
				if not unit_def then
					table.insert(errors, string.format("Invalid UnitDataDefId '%s'", unitdatadef_id or ""))
				else
					local species = unit_def and unit_def.species or "Human"
					if species == "Human" then
						local prefix = not self.use_weapons and "civ" or "ar"
						local stance = self.idle_stance ~= g_StanceActionDefault and self.idle_stance or ".*"
						local action = self.idle_action ~= g_StanceActionDefault and self.idle_action or ".*"
						local anim_regex = string.format("%s_%s_%s", prefix, stance, action)
						local anims = ValidAnimationsCombo(self)
						local anim_match = false
						for _, a in ipairs(anims) do
							if string.match(a, anim_regex) then
								anim_match = true
								break
							end
						end
						if not anim_match then
							table.insert(errors, string.format(
								"These values don't match a valid animation: [%s] Use Weapons - %s; Idle stance - %s; Idle animation action - %s",
								next(anims) and anims[1] or "no anims present",
								self.use_weapons and "Yes" or "No",
								self.idle_stance or "default",
								self.idle_action or "default"
							))
						end
					end
				end
			end
			
			return next(errors) and table.concat(errors, "\n")
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "OnEditorSetProperty",
		'params', "prop_id, old_value, ged",
		'code', function (self, prop_id, old_value, ged)
			if prop_id == "idle_stance" then
				local actions = GetIdleAnimStanceActions(self.use_weapons, self.idle_stance)
				if not table.find(actions, self.idle_action) then
					self:SetProperty("idle_action", actions[1])
				end
			end
		end,
	}),
	PlaceObj('PropertyDefText', {
		'id', "Type",
		'name', "Type",
		'read_only', true,
		'no_edit', true,
		'default', "UnitMarker",
		'translate', false,
	}),
	PlaceObj('PropertyDefText', {
		'id', "Entity",
		'name', "Entity",
		'dont_save', true,
		'read_only', true,
		'no_edit', true,
		'default', "WayPoint",
		'translate', false,
	}),
	PlaceObj('PropertyDefText', {
		'id', "EditorIcon",
		'name', "EditorIcon",
		'dont_save', true,
		'read_only', true,
		'no_edit', true,
		'default', "CommonAssets/UI/Icons/user",
		'translate', false,
	}),
	PlaceObj('PropertyDefPresetIdList', {
		'category', "Banters",
		'id', "SpecificBanters",
		'name', "SpecificBanters",
		'help', "Specific Banters to play when interacted with.",
		'preset_class', "BanterDef",
	}),
	PlaceObj('PropertyDefStringList', {
		'category', "Banters",
		'id', "BanterGroups",
		'name', "Banters from group",
		'help', "Add groups of banters at once",
		'items', function (self) return PresetGroupsCombo("BanterDef") end,
		'arbitrary_value', true,
	}),
	PlaceObj('PropertyDefBool', {
		'category', "Banters",
		'id', "BantersSequential",
		'name', "Play all banters one after another",
		'help', "By default on unit interaction one of the banters from the list is played. If this is checked then all the banters will be played in succession.",
	}),
	PlaceObj('PropertyDefPresetIdList', {
		'category', "Banters",
		'id', "ApproachedBanters",
		'name', "ApproachedBanters",
		'help', "Banters to play when the unit is approached within a specified range.",
		'preset_class', "BanterDef",
	}),
	PlaceObj('PropertyDefCombo', {
		'category', "Banters",
		'id', "ApproachBanterGroup",
		'name', "Approach Banters from group",
		'help', "Add a group of approach banters at once",
		'items', function (self) return PresetGroupsCombo("BanterDef") end,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Banters",
		'id', "ApproachRadius",
		'name', "ApproachRadius",
		'help', "How close a player controled unit has to be to trigger the approached banters.",
		'default', 8,
	}),
	PlaceObj('PropertyDefText', {
		'category', "Interaction",
		'id', "InteractionName",
		'name', "Interaction Name",
	}),
	PlaceObj('PropertyDefNestedList', {
		'category', "Interaction",
		'id', "InteractionConditions",
		'name', "Interaction Enable Conditions",
		'help', "The interaction effects and overwrites will apply if these pass as true.",
		'base_class', "Condition",
	}),
	PlaceObj('PropertyDefBool', {
		'category', "Interaction",
		'id', "ExecuteInteractionEffectsSequentially",
		'name', "Execute Sequentially",
	}),
	PlaceObj('PropertyDefNestedList', {
		'category', "Interaction",
		'id', "InteractionEffects",
		'name', "Interaction Effects",
		'base_class', "Effect",
	}),
	PlaceObj('PropertyDefChoice', {
		'category', "Interaction",
		'id', "InteractionVisuals",
		'name', "InteractionVisuals",
		'items', function (self) return AllInteractableIcons() end,
	}),
	PlaceObj('PropertyDefChoice', {
		'category', "Spawn Object",
		'id', "Side",
		'default', "neutral",
		'items', function (self) return table.map(GetCurrentCampaignPreset().Sides, "Id") end,
	}),
	PlaceObj('PropertyDefBool', {
		'id', "kill_on_spawn",
		'dont_save', true,
		'no_edit', true,
	}),
	PlaceObj('PropertyDefBool', {
		'category', "Spawn Object",
		'id', "Persistent",
		'help', 'triggering the spawn multiple times will result in the same units, preserving any changes in their data; this is ignored if the template to be spawned has a non-empty "Persistent Session Id" (works as if it is enabled)',
	}),
	PlaceObj('PropertyDefBool', {
		'category', "Spawn Object",
		'id', "AlwaysSpawn",
		'name', "Spawn when gone",
		'help', "Even if the unit is despawned or left, still spawn here",
	}),
	PlaceObj('PropertyDefBool', {
		'category', "Spawn Object",
		'id', "ConflictIgnore",
		'name', "Conflict Ignore",
		'help', "The units from this marker are ignoring conflicts and don't use the Cower command.",
	}),
	PlaceObj('PropertyDefText', {
		'category', "Spawn Object",
		'id', "SessionId",
		'name', "Session ID",
		'extra_code', "no_edit = function(self) return not self.Persistent end",
		'translate', false,
	}),
	PlaceObj('PropertyDefNestedList', {
		'category', "Spawn Object",
		'id', "UnitDataSpawnDefs",
		'name', "UnitData Spawn Templates",
		'help', "Choose mercenary, enemy, or NPC from the Unit editor to spawn, using weighted random.",
		'base_class', "UnitDataSpawnData",
		'inclusive', true,
	}),
	PlaceObj('PropertyDefCombo', {
		'category', "Animation",
		'id', "idle_stance",
		'name', "Idle stance",
		'default', "do not change",
		'items', function (self) return GetIdleAnimStances(self.use_weapons) end,
	}),
	PlaceObj('PropertyDefCombo', {
		'category', "Animation",
		'id', "idle_action",
		'name', "Idle Action",
		'default', "do not change",
		'items', function (self) return GetIdleAnimStanceActions(self.use_weapons, self.idle_stance) end,
	}),
	PlaceObj('PropertyDefText', {
		'id', "EditorRolloverText",
		'name', "EditorRolloverText",
		'dont_save', true,
		'read_only', true,
		'no_edit', true,
		'default', "Spawn/despawn Unit from specified TemplateIds when spawn/despawn conditions are met",
		'translate', false,
	}),
	PlaceObj('PropertyDefCombo', {
		'category', "",
		'id', "Routine",
		'default', "StandStill",
		'items', function (self) return UnitRoutines end,
	}),
	PlaceObj('PropertyDefCombo', {
		'category', "",
		'id', "RoutineArea",
		'default', "self",
		'items', function (self) local g = table.copy(GridMarkerGroupsCombo()) g[1+#g] = "self" return g end,
	}),
	PlaceObj('PropertyDefPresetIdList', {
		'category', "Spawn Object",
		'id', "status_effects",
		'name', "Status Effects",
		'preset_class', "CharacterEffectCompositeDef",
	}),
	PlaceObj('ClassConstDef', {
		'name', "unit_template_idx",
		'type', "string_list",
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"UnitPropertiesStats",
		"ZuluModifiable",
		"DamagePredictable",
	},
	group = "Zulu",
	id = "UnitProperties",
	PlaceObj('PropertyDefBool', {
		'category', "Appearance",
		'id', "Headshot",
		'name', "Headshot",
		'help', "Set a blown out head",
		'template', true,
	}),
	PlaceObj('PropertyDefText', {
		'id', "CurrentSide",
		'translate', false,
	}),
	PlaceObj('PropertyDefText', {
		'id', "lastFiringMode",
		'name', "LastFiringMode",
		'translate', false,
	}),
	PlaceObj('PropertyDefUIImage', {
		'category', "Appearance",
		'id', "Portrait",
		'template', true,
		'default', "UI/MercsPortraits/placeholder_portrait",
		'image_preview_size', 100,
	}),
	PlaceObj('PropertyDefUIImage', {
		'category', "Appearance",
		'id', "BigPortrait",
		'template', true,
		'default', "UI/Mercs/placeholder_character",
		'image_preview_size', 100,
	}),
	PlaceObj('PropertyDefBool', {
		'category', "General",
		'id', "IsMercenary",
		'name', "Is mercenary",
		'help', "Can the player have this unit in their team.",
		'template', true,
	}),
	PlaceObj('PropertyDefText', {
		'category', "General",
		'id', "Name",
		'name', "Full name",
		'help', "The full name of the merc. When the full name is needed this entire string is used and the nickname is ignored.",
		'template', true,
		'lines', 1,
		'max_lines', 1,
	}),
	PlaceObj('PropertyDefText', {
		'category', "General",
		'id', "Nick",
		'name', "Nickname",
		'help', "The nickname or short name of the merc",
		'template', true,
		'extra_code', 'no_edit = function(self) return not IsMerc(self) and self.id ~= "Dummy" end',
		'lines', 1,
		'max_lines', 1,
	}),
	PlaceObj('PropertyDefBool', {
		'category', "Stats",
		'id', "Randomization",
		'name', "Randomization",
		'help', "When true any instance of this unit randomizes the stats of the unit by +/- 10 points",
		'template', true,
		'extra_code', "no_edit = function(self) return IsMerc(self)  end",
	}),
	PlaceObj('PropertyDefText', {
		'category', "General",
		'id', "AllCapsNick",
		'name', "AllCapsNickname",
		'help', "The nickname or short name of the merc with all caps letters (needed by some UI)",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'lines', 1,
		'max_lines', 1,
	}),
	PlaceObj('PropertyDefBool', {
		'category', "General",
		'id', "elite",
		'name', "Elite",
		'help', "Give the unit a unique random name.",
		'template', true,
		'extra_code', "no_edit = function(self) return IsMerc(self) end",
	}),
	PlaceObj('PropertyDefCombo', {
		'category', "General",
		'id', "eliteCategory",
		'name', "Elite Category",
		'help', "From which group of names to select. If nothing is selected it will pick from any of the groups.",
		'template', true,
		'extra_code', "no_edit = function(self) return IsMerc(self) end",
		'items', function (self) return PresetGroupsCombo("EliteEnemyName") end,
	}),
	PlaceObj('PropertyDefCombo', {
		'category', "General",
		'id', "Affiliation",
		'template', true,
		'default', "AIM",
		'items', function (self) return Affiliations end,
	}),
	PlaceObj('PropertyDefCombo', {
		'category', "Hiring",
		'id', "HireStatus",
		'name', "Initial Hire Status",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'default', "Available",
		'items', function (self) return PresetGroupCombo("MercHireStatus", "Default") end,
	}),
	PlaceObj('PropertyDefText', {
		'category', "Hiring",
		'id', "Bio",
		'name', "Bio",
		'help', "Biography of the merc",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'lines', 4,
		'max_lines', 10,
	}),
	PlaceObj('PropertyDefPresetId', {
		'category', "Hiring",
		'id', "Nationality",
		'name', "Nationality",
		'help', "Is shown next to the bio in the hire UI",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'preset_class', "MercNationalities",
	}),
	PlaceObj('PropertyDefText', {
		'category', "Hiring",
		'id', "Title",
		'name', "Title",
		'help', "Is shown next to the bio in the hire UI",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
	}),
	PlaceObj('PropertyDefText', {
		'category', "Hiring",
		'id', "Email",
		'name', "Email",
		'help', "Is shown in the AIM chat.",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
	}),
	PlaceObj('PropertyDefText', {
		'category', "Hiring",
		'id', "snype_nick",
		'name', "snype Nick",
		'help', "Is shown in the AIM chat.",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
	}),
	PlaceObj('PropertyDefNestedList', {
		'category', "Hiring - Conditions",
		'id', "Refusals",
		'name', "Refusals",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'base_class', "MercChatRefusal",
	}),
	PlaceObj('PropertyDefNestedList', {
		'category', "Hiring - Conditions",
		'id', "Haggles",
		'name', "Haggles",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'base_class', "MercChatHaggle",
	}),
	PlaceObj('PropertyDefNestedList', {
		'category', "Hiring - Conditions",
		'id', "HaggleRehire",
		'name', "Rehire Haggles",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'base_class', "MercChatHaggle",
	}),
	PlaceObj('PropertyDefNestedList', {
		'category', "Hiring - Conditions",
		'id', "Mitigations",
		'name', "Mitigations",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'base_class', "MercChatMitigation",
	}),
	PlaceObj('PropertyDefNestedList', {
		'category', "Hiring - Conditions",
		'id', "ExtraPartingWords",
		'name', "Parting Words",
		'help', "If any conditional passing remark passes it is played instead of the default one.",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'base_class', "MercChatBranch",
		'inclusive', true,
		'no_descendants', true,
	}),
	PlaceObj('PropertyDefNestedList', {
		'category', "Hiring - Lines",
		'id', "Offline",
		'name', "Offline",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'base_class', "ChatMessage",
	}),
	PlaceObj('PropertyDefNestedList', {
		'category', "Hiring - Lines",
		'id', "GreetingAndOffer",
		'name', "Greetings And Offer",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'base_class', "ChatMessage",
	}),
	PlaceObj('PropertyDefNestedList', {
		'category', "Hiring - Lines",
		'id', "ConversationRestart",
		'name', "Conversation Restart",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'base_class', "ChatMessage",
	}),
	PlaceObj('PropertyDefNestedList', {
		'category', "Hiring - Lines",
		'id', "IdleLine",
		'name', "Idle",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'base_class', "ChatMessage",
	}),
	PlaceObj('PropertyDefNestedList', {
		'category', "Hiring - Lines",
		'id', "PartingWords",
		'name', "PartingWords",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'base_class', "ChatMessage",
	}),
	PlaceObj('PropertyDefNestedList', {
		'category', "Hiring - Lines",
		'id', "RehireIntro",
		'name', "RehireIntro",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'base_class', "ChatMessage",
	}),
	PlaceObj('PropertyDefNestedList', {
		'category', "Hiring - Lines",
		'id', "RehireOutro",
		'name', "RehireOutro",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'base_class', "ChatMessage",
	}),
	PlaceObj('PropertyDefChoice', {
		'category', "Hiring - Parameters",
		'id', "MedicalDeposit",
		'name', "Medical Deposit",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'default', "small",
		'items', function (self) return { "small", "none", "large", "extreme" } end,
	}),
	PlaceObj('PropertyDefChoice', {
		'category', "Hiring - Parameters",
		'id', "DurationDiscount",
		'name', "Duration Discount",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'default', "normal",
		'items', function (self) return { "normal", "none", "long only" } end,
	}),
	PlaceObj('PropertyDefChoice', {
		'category', "Hiring - Parameters",
		'id', "Haggling",
		'name', "Haggling",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'default', "normal",
		'items', function (self) return { "normal", "low", "high" } end,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Hiring - Parameters",
		'id', "StartingSalary",
		'help', "The salary at the starting level (whichever it is).",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'default', 1000,
		'min', 0,
		'max', 20000,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Hiring - Parameters",
		'id', "SalaryIncrease",
		'help', "The percentange of salary increase per level.",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'default', 250,
		'scale', 1000,
		'min', 0,
		'max', 10000,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Hiring - Parameters",
		'id', "SalaryLv1",
		'name', "(To Be Deleted) Salary Lv 1",
		'help', "The amount of money it costs to hire this merc for 1 day at level 1",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'default', 1000,
		'min', 0,
		'max', 20000,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Hiring - Parameters",
		'id', "SalaryMaxLv",
		'name', "(To Be Deleted) Max Lv Daily Salary",
		'help', "The amount of money it costs to hire this merc for 1 day at max level",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'default', 10000,
		'min', 0,
		'max', 20000,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Hiring - Parameters",
		'id', "SalaryPreview",
		'name', "Salary Level 10",
		'dont_save', true,
		'read_only', true,
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'default', 0,
	}),
	PlaceObj('PropertyDefText', {
		'category', "Hiring",
		'id', "LegacyNotes",
		'name', "Legacy Notes",
		'help', "Any info about the merc from previous titles.",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'translate', false,
		'lines', 4,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "XP",
		'id', "StartingLevel",
		'name', "Starting Level",
		'help', "The level at which this merc starts in a new game",
		'template', true,
		'default', 1,
		'slider', true,
		'min', 1,
		'max', 10,
	}),
	PlaceObj('PropertyDefBool', {
		'category', "General",
		'id', "immortal",
		'name', "Immortal",
		'template', true,
		'extra_code', "no_edit = function(self) return IsMerc(self) end",
	}),
	PlaceObj('PropertyDefBool', {
		'category', "General",
		'id', "ImportantNPC",
		'name', "ImportantNPC",
		'help', "Units with this flag have a green badge above them.",
		'template', true,
		'extra_code', "no_edit = function(self) return IsMerc(self) end",
	}),
	PlaceObj('PropertyDefBool', {
		'category', "General",
		'id', "reincarnate",
		'name', "Reincarnate",
		'template', true,
		'extra_code', "no_edit = function(self) return IsMerc(self) end",
	}),
	PlaceObj('PropertyDefBool', {
		'category', "General",
		'id', "dummy",
		'name', "Dummy",
		'template', true,
		'extra_code', "no_edit = function(self) return IsMerc(self) end",
	}),
	PlaceObj('PropertyDefBool', {
		'category', "General",
		'id', "militia",
		'name', "Militia Unit",
		'no_edit', true,
		'template', true,
		'extra_code', "no_edit = function(self) return IsMerc(self) end",
	}),
	PlaceObj('PropertyDefBool', {
		'category', "General",
		'id', "villain",
		'name', "Recurring Villain",
		'template', true,
		'extra_code', "no_edit = function(self) return IsMerc(self) end",
	}),
	PlaceObj('PropertyDefBool', {
		'category', "General",
		'id', "neutral_retaliate",
		'name', "Retaliate",
		'help', "if enabled and the unit is Neutral, they will become hostile when damaged",
		'template', true,
		'extra_code', "no_edit = function(self) return IsMerc(self) end",
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "General",
		'id', "max_dead_slot_tiles",
		'name', "max_dead_slot_tiles",
		'help', "Max tiles in InventoryDead slot. It's caclulated on death, when a unit drops its loot.",
		'no_edit', true,
		'template', true,
		'default', 24,
		'min', 1,
		'max', 24,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "VillainHealWoundProgress",
		'help', "Used only for villains",
		'no_edit', true,
		'default', 0,
	}),
	PlaceObj('PropertyDefStringList', {
		'category', "AI",
		'id', "AIKeywords",
		'template', true,
		'items', function (self) return AIKeywordsCombo end,
		'arbitrary_value', true,
	}),
	PlaceObj('PropertyDefPresetId', {
		'category', "AI",
		'id', "archetype",
		'name', "Archetype",
		'template', true,
		'extra_code', "no_edit = function(self) return IsMerc(self) end",
		'preset_class', "AIArchetype",
		'default', "Soldier",
	}),
	PlaceObj('PropertyDefPresetId', {
		'category', "AI",
		'id', "script_archetype",
		'name', "Archetype",
		'no_edit', true,
		'no_validate', true,
		'template', true,
		'preset_class', "AIArchetype",
		'default', "",
	}),
	PlaceObj('PropertyDefPresetId', {
		'category', "AI",
		'id', "role",
		'name', "Enemy Role",
		'template', true,
		'extra_code', "no_edit = function(self) return IsMerc(self) end",
		'preset_class', "EnemyRole",
		'default', "Default",
	}),
	PlaceObj('PropertyDefBool', {
		'category', "AI",
		'id', "CanManEmplacements",
		'name', "Can Man Emplacements",
		'template', true,
		'extra_code', "no_edit = function(self) return IsMerc(self) end",
		'default', true,
	}),
	PlaceObj('PropertyDefPresetId', {
		'category', "AI",
		'id', "current_archetype",
		'name', "Archetype",
		'read_only', true,
		'no_edit', true,
		'template', true,
		'extra_code', "no_edit = function(self) return IsMerc(self) end",
		'preset_class', "AIArchetype",
	}),
	PlaceObj('PropertyDefPresetId', {
		'category', "AI",
		'id', "RepositionArchetype",
		'name', "Reposition Archetype",
		'help', "if not specified the unit will use it's normal archetype for Reposition action",
		'template', true,
		'extra_code', "no_edit = function(self) return IsMerc(self) end",
		'preset_class', "AIArchetype",
	}),
	PlaceObj('PropertyDefBool', {
		'category', "AI",
		'id', "AlwaysUseOpeningAttack",
		'name', "Always Use Opening Attack",
		'template', true,
		'extra_code', "no_edit = function(self) return IsMerc(self) end",
	}),
	PlaceObj('PropertyDefChoice', {
		'category', "AI",
		'id', "OpeningAttackType",
		'name', "Opening Attack Type",
		'template', true,
		'extra_code', "no_edit = function(self) return IsMerc(self) end",
		'default', "Default",
		'items', function (self) return { "Default", "Overwatch", "PinDown" } end,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "AI",
		'id', "PinnedDownChance",
		'name', "PinnedDown Chance",
		'help', "chance to use PinnedDown archetype when the unit is pinned down by enemy/enemies",
		'template', true,
		'extra_code', "no_edit = function(self) return IsMerc(self) end",
		'default', 50,
		'min', 0,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "AI",
		'id', "MaxAttacks",
		'help', "max attacks to perform per turn",
		'template', true,
		'extra_code', "no_edit = function(self) return IsMerc(self) end",
		'default', 3,
		'min', 1,
	}),
	PlaceObj('PropertyDefFunc', {
		'category', "AI",
		'id', "PickCustomArchetype",
		'help', "implement custom archetype selection logic for this unit; standard retreat/reposition logic overrides this choice",
		'template', true,
		'extra_code', "no_edit = function(self) return IsMerc(self) end",
		'params', "self, proto_context",
	}),
	PlaceObj('PropertyDefFunc', {
		'category', "Equipment",
		'id', "CustomEquipGear",
		'help', "implement custom logic for equipping starting gear for this unit; standard gearing logic is applied after this",
		'template', true,
		'params', "self, items",
	}),
	PlaceObj('ClassMethodDef', {
		'name', "SelectArchetype",
		'params', "proto_context",
		'code', function (self, proto_context)
			local archetype
			local func = empty_func
			
			if IsKindOf(self, "Unit") then
				local emplacement = g_Combat and g_Combat:GetEmplacementAssignment(self)
				if self.retreating then
					archetype = "Deserter"
				elseif self:HasStatusEffect("Panicked") then
					archetype = "Panicked"
				elseif self:HasStatusEffect("Berserk") then
					archetype = "Berserk"
				elseif emplacement then
					assert(self.CanManEmplacements)
					archetype = "EmplacementGunner"
					proto_context.target_interactable = emplacement
				elseif self.command == "Reposition" and self.RepositionArchetype then
					archetype = self.RepositionArchetype
				end
				
				-- check for scout archetype first
				local can_scout = not archetype
				can_scout = can_scout and (not g_Encounter or g_Encounter:CanScout())
				can_scout = can_scout and self.script_archetype ~= "GuardArea"
				if can_scout then
					local enemies = self:GetVisibleEnemies()
					if #enemies == 0 then
						self.last_known_enemy_pos = self.last_known_enemy_pos or AIPickScoutLocation(self)
						if self.last_known_enemy_pos then
							archetype = "Scout_LastLocation"
						end
					end
				end
				
				if not archetype then
					for _, descr in pairs(g_Pindown) do
						if descr.target == self then
							if self:Random(100) < self.PinnedDownChance then
								archetype = "PinnedDown"
							end
							break
						end
					end
				end
				local template= UnitDataDefs[self.unitdatadef_id]
				func = template and template.PickCustomArchetype or self.PickCustomArchetype
			end
			
			self.current_archetype = archetype or func(self, proto_context) or self.archetype or "Assault"
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "EquipStartingGear",
		'params', "items",
		'code', function (self, items)
			local func = empty_func
			if IsKindOf(self, "UnitData") then
				local template= UnitDataDefs[self.class]
				func = template and template.CustomEquipGear or self.CustomEquipGear
			end
			
			-- priority custom gearing rules
			func(self, items)
			
			-- default gearing rules:
			-- make sure there's an equipped weapon if possible
			if not self:GetItemInSlot("Handheld A", "BaseWeapon") then
				local has_weapon = self:TryEquip(items, "Handheld A", "Firearm")
				has_weapon = has_weapon or self:TryEquip(items, "Handheld A", "MeleeWeapon")
				has_weapon = has_weapon or self:TryEquip(items, "Handheld A", "HeavyWeapon")
			end
			
			local equipped = {}
			-- locked items that are not weapons add to the first inventory slot
			for i, item in ipairs(items) do
				if item.locked and not item:IsWeapon() and not IsKindOf(item, "Armor") then -- lock to the first inventory slot
					if self:CanAddItem("Inventory", item) then
						self:AddItem("Inventory", item)
						equipped[i] = true
					end
				end				
			end
			-- equip the rest of the equppable items when possible
			
			for i, item in ipairs(items) do
				if not equipped[i] then
					local slot
					if IsKindOf(item, "QuickSlotItem") then
						if self:CanAddItem("Handheld A", item) then
							slot = "Handheld A"
						elseif self:CanAddItem("Handheld B", item) then
							slot = "Handheld B"
						end
					elseif IsKindOf(item, "Armor") and not self:GetItemInSlot(item.Slot) then
						slot = item.Slot
					end
					if slot and self:CanAddItem(slot, item) then
						self:AddItem(slot, item)
						equipped[i] = true
					end
				end
			end
			
			-- make sure all equipped firearms have ammo
			for _, slot in ipairs({"Handheld A", "Handheld B"}) do
				self:ForEachItemInSlot(slot, "Firearm", function(weapon)
					if not weapon.ammo or weapon.ammo.Amount <= 0 then
						local ammo = GetAmmosWithCaliber(weapon.Caliber, "sort")[1]
						if ammo then
							local tempAmmo = PlaceInventoryItem(ammo.id)
							tempAmmo.Amount = tempAmmo.MaxStacks
							weapon:Reload(tempAmmo, "suspend_fx")
							DoneObject(tempAmmo)
						end
					end
				end)
			end
			
			-- place the rest in Inventory slot
			for i, item in ipairs(items) do
				if not equipped[i] then
					local pos, reason = self:AddItem("Inventory", item)
					if not pos then
						print("Couldn't add starting item \'", item.class, "\' to unit", self.class, "because", reason, "max slots", self:GetMaxTilesInSlot("Inventory"))
					end		
				end
			end
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "TryEquip",
		'params', "items, slot, class",
		'code', function (self, items, slot, class)
			local idx
			for i, item in ipairs(items) do
				local match = class ~= "Firearm" or not IsKindOfClasses(item, "HeavyWeapon", "FlareGun")
				match = match and IsKindOf(item, class) 
				if match and self:CanAddItem(slot, item) then
					idx = i
					break
				end
			end
			
			if idx then
				self:AddItem(slot, items[idx])
				table.remove(items, idx)
			end
			return not not idx
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "TryLoadAmmo",
		'params', "slot, weapon_class, ammo_id",
		'code', function (self, slot, weapon_class, ammo_id)
			local found
			local ammo = g_Classes[ammo_id]
			if not ammo then
				StoreErrorSource(self, string.format("Unit %s trying to load invalid ammo type '%s'", self.unitdatadef_id or self.class, ammo_id))
				return
			end
			self:ForEachItemInSlot(slot, weapon_class, function(weapon)
				if weapon.Caliber ~= ammo.Caliber then
					StoreErrorSource(self, string.format("Unit %s trying to load incompatible ammo type '%s' in their '%s'", self.unitdatadef_id or self.class, ammo_id, weapon.class))
					return
				end
				local tempAmmo = PlaceInventoryItem(ammo_id)
				tempAmmo.Amount = tempAmmo.MaxStacks
				weapon:Reload(tempAmmo, "suspend_fx")
				DoneObject(tempAmmo)	
			end)
		end,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Villain",
		'id', "Lives",
		'name', "",
		'template', true,
		'extra_code', "no_edit = function(self) return not self.villain end",
		'default', 3,
		'min', 1,
		'max', 5,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "XP",
		'id', "Experience",
		'no_edit', true,
		'template', true,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "XP",
		'id', "RewardExperience",
		'name', "XP override",
		'help', "The amount of XP the unit will reward its enemies when defeated. If left unset the XPRewardTable table is used.",
		'template', true,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "XP",
		'id', "statGainingPoints",
		'no_edit', true,
		'template', true,
		'default', 0,
		'min', 0,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "XP",
		'id', "UnitPower",
		'help', "Unit power used in autoresolve: base unitLevel if non merc * basePower const",
		'dont_save', true,
		'read_only', true,
		'template', true,
		'default', 0,
		'min', 0,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "XP",
		'id', "unitPowerModifier",
		'name', "Unit Power Modifier",
		'help', "How effective(%) is the unit power in autoresolve.",
		'template', true,
		'default', 100,
		'min', 0,
	}),
	PlaceObj('PropertyDefChoice', {
		'category', "Villain",
		'id', "DefeatBehavior",
		'name', "Defeat Behavior",
		'template', true,
		'extra_code', "no_edit = function(self) return not self.villain end",
		'default', "Dead",
		'items', function (self) return { "Dead", "Defeated" } end,
	}),
	PlaceObj('PropertyDefChoice', {
		'category', "Villain",
		'id', "RetreatBehavior",
		'name', "Retreat Behavior",
		'template', true,
		'extra_code', "no_edit = function(self) return not self.villain end",
		'default', "Full Retreat",
		'items', function (self) return { "None", "Individual", "Full Retreat" } end,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Derived Stats",
		'id', "ActionPoints",
		'name', "Action Points",
		'help', "This parameters determines how much actions a merc can do in a single round",
		'extra_code', "no_edit = true",
		'scale', "AP",
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Derived Stats",
		'id', "MaxActionPoints",
		'name', "Max Action Points",
		'help', "This parameters determines how much actions a merc can do in a single round",
		'dont_save', true,
		'read_only', true,
		'no_edit', true,
		'template', true,
		'scale', "AP",
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetMaxActionPoints",
		'code', function (self)
			local level = self:GetLevel()
			return ((3 + self:GetProperty("Agility") / 10) + (level / 3)) * const.Scale.AP
		end,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Derived Stats",
		'id', "Tiredness",
		'read_only', true,
		'no_edit', true,
		'template', true,
		'default', 0,
		'min', -1,
		'max', 3,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "SetTired",
		'params', "value",
		'code', function (self, value)
			value = Clamp(value or 0, -1, 3)
			if self.Tiredness == value then
				return
			end
			
			self:RemoveStatusEffect("WellRested")
			self:RemoveStatusEffect("Tired")
			self:RemoveStatusEffect("Exhausted")
			self:RemoveStatusEffect("Unconscious")
			
			local oldValue = self.Tiredness or 0
			self.Tiredness = value
			if value == 3 then
				self.HitPoints = Max(1, self.HitPoints)
			elseif value~=0 and UnitTirednessEffect[value] then
				self:AddStatusEffect(UnitTirednessEffect[value])
			end
			
			if oldValue <= 0 and value >= 0 then
				Msg("UnitTiredAdded", self)
			elseif oldValue > 0 and value <= 0 then
				Msg("UnitTiredRemoved", self)
			end
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "ChangeTired",
		'params', "delta",
		'code', function (self, delta)
			self:SetTired(self.Tiredness + delta)
		end,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Derived Stats",
		'id', "RestTimer",
		'read_only', true,
		'no_edit', true,
		'template', true,
		'default', 0,
		'min', 0,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Derived Stats",
		'id', "TravelTimerStart",
		'read_only', true,
		'no_edit', true,
		'template', true,
		'default', 0,
		'min', 0,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Derived Stats",
		'id', "TravelTime",
		'read_only', true,
		'no_edit', true,
		'template', true,
		'default', 0,
		'min', 0,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Derived Stats",
		'id', "HitPoints",
		'name', "Hit Points",
		'extra_code', "no_edit = true",
		'default', -1,
		'min', -1,
		'max', 100,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Derived Stats",
		'id', "MaxHitPoints",
		'name', "Max Hit Points",
		'read_only', true,
		'no_edit', true,
		'template', true,
		'default', 0,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetInitialMaxHitPoints",
		'code', function (self)
			local mod = self:GetProperty("villain") and const.Combat.LieutenantHpMod or 100
			local maxhp = MulDivRound(self:GetProperty("Health"), mod, 100)
			if HasPerk(self, "BeefedUp") then
				maxhp = MulDivRound(maxhp, 100 + CharacterEffectDefs.BeefedUp:ResolveValue("bonus_health"), 100)
			end
			return maxhp
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetModifiedMaxHitPoints",
		'code', function (self)
			local maxhp = self:GetInitialMaxHitPoints()
			local positive_mods_only = maxhp
			
			local idx = self:HasStatusEffect("Wounded")
			local effect = idx and self.StatusEffects[idx]
			if effect then
				local value = effect:ResolveValue("MaxHpReductionPerStack") or 0
				local maxreduce = effect:ResolveValue("MinMaxHp") or 0
				local min = MulDivRound(maxhp, maxreduce, 100)
				maxhp = Max(min, maxhp - effect.stacks * value)
			end
			return maxhp, positive_mods_only
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetInventoryMaxSlots",
		'code', function (self)
			return IsMerc(self) and Max(4, (self.Strength - 30)/5) or self.max_dead_slot_tiles or 20
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "IsDead",
		'code', function (self)
			return self.HitPoints <= 0
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetHealthAsText",
		'code', function (self)
			local max, max_positive = self:GetModifiedMaxHitPoints()
			if self:UIObscured() or self:UIConcealed() then
				return HpToText.Hidden
			elseif self.HitPoints >= 90 then
				return HpToText.Excellent
			elseif self.HitPoints >= 75 then
				return HpToText.Strong
			elseif self.HitPoints >= 60 then
				return HpToText.Healthy
			elseif self.HitPoints >= 45 and self.HitPoints ~= max_positive then
				return HpToText.Poor
			elseif self.HitPoints >= 25 and self.HitPoints ~= max_positive then
				return HpToText.Wounded
			elseif self.HitPoints >= 10 and self.HitPoints ~= max_positive then
				return HpToText.Critical
			elseif self.HitPoints > 0 and self.HitPoints ~= max_positive then
				return HpToText.Dying
			elseif self.HitPoints == 0 then
				return HpToText.Dead
			else 
				return HpToText.Uninjured
			end
		end,
	}),
	PlaceObj('PropertyDefStringList', {
		'category', "Likes And Dislikes",
		'id', "Likes",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'items', function (self) return MercPresetCombo() end,
	}),
	PlaceObj('PropertyDefStringList', {
		'category', "Likes And Dislikes",
		'id', "LearnToLike",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'items', function (self) return MercPresetCombo() end,
	}),
	PlaceObj('PropertyDefStringList', {
		'category', "Likes And Dislikes",
		'id', "Dislikes",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'items', function (self) return MercPresetCombo() end,
	}),
	PlaceObj('PropertyDefStringList', {
		'category', "Likes And Dislikes",
		'id', "LearnToDislike",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'items', function (self) return MercPresetCombo() end,
	}),
	PlaceObj('PropertyDefStringList', {
		'category', "Likes And Dislikes",
		'id', "LikedBy",
		'dont_save', true,
		'read_only', true,
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'items', function (self) return MercPresetCombo() end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetLikedBy",
		'code', function (self)
			local id = IsKindOf(self, "UnitDataCompositeDef") and self.id or self.unitdatadef_id
			local res = {}
			for k, v in pairs(UnitDataDefs) do
				if table.find(v:GetProperty("Likes"), id) then
					res[#res+1] = v.id
				end
			end
			return res
		end,
	}),
	PlaceObj('PropertyDefStringList', {
		'category', "Likes And Dislikes",
		'id', "DislikedBy",
		'dont_save', true,
		'read_only', true,
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'items', function (self) return MercPresetCombo() end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetDislikedBy",
		'code', function (self)
			local id = IsKindOf(self, "UnitDataCompositeDef") and self.id or self.unitdatadef_id
			local res = {}
			for k, v in pairs(UnitDataDefs) do
				if table.find(v:GetProperty("Dislikes"), id) then
					res[#res+1] = v.id
				end
			end
			return res
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetUnitPower",
		'code', function (self)
			return GetPowerOfUnit(self, "noMods")
		end,
	}),
	PlaceObj('PropertyDefPresetIdList', {
		'category', "Perks",
		'id', "StartingPerks",
		'name', "Starting Perks",
		'template', true,
		'extra_code', "editor_preview = true",
		'preset_class', "CharacterEffectCompositeDef",
		'preset_filter', function (preset, obj, prop_meta)
			return preset.object_class == "Perk"
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetStartingPerks",
		'code', function (self)
			return self.StartingPerks
		end,
	}),
	PlaceObj('PropertyDefText', {
		'id', "Operation",
		'name', "Operation",
		'no_edit', true,
		'template', true,
		'default', "Idle",
		'translate', false,
	}),
	PlaceObj('PropertyDefText', {
		'id', "OperationProfession",
		'no_edit', true,
		'template', true,
		'default', "Idle",
		'translate', false,
	}),
	PlaceObj('PropertyDefTable', {
		'id', "OperationProfessions",
		'name', "OperationProfessions",
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "OperationInitialETA",
		'no_edit', true,
		'template', true,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "HiredUntil",
		'no_edit', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "Squad",
		'no_edit', true,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "OldSquad",
		'no_edit', true,
		'default', 0,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "heal_wound_progress",
		'no_edit', true,
		'default', 0,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "wounds_being_treated",
		'no_edit', true,
		'default', 0,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "arriving_progress",
		'no_edit', true,
		'default', 0,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "traveling_progress",
		'help', "Travelling activity progress",
		'no_edit', true,
		'default', 0,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "randr_activity_progress",
		'no_edit', true,
		'default', 0,
		'min', 0,
	}),
	PlaceObj('PropertyDefText', {
		'id', "arrival_dir",
		'no_edit', true,
		'translate', false,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "gather_intel_progress",
		'help', "Intel item is discovered when progress is 1000",
		'no_edit', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'default', 0,
		'min', 0,
	}),
	PlaceObj('PropertyDefText', {
		'id', "gather_intel_item_id",
		'no_edit', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'translate', false,
	}),
	PlaceObj('PropertyDefText', {
		'id', "gather_intel_sector_id",
		'no_edit', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'translate', false,
	}),
	PlaceObj('PropertyDefTable', {
		'id', "stat_learning",
	}),
	PlaceObj('PropertyDefTable', {
		'id', "training_activity_progress",
	}),
	PlaceObj('PropertyDefBool', {
		'id', "already_spawned_on_map",
		'no_edit', true,
	}),
	PlaceObj('PropertyDefNestedList', {
		'id', "stains",
		'no_edit', true,
		'base_class', "UnitStain",
		'inclusive', true,
	}),
	PlaceObj('PropertyDefText', {
		'id', "retreat_to_sector",
		'no_edit', true,
		'translate', false,
	}),
	PlaceObj('PropertyDefNestedList', {
		'category', "Appearance",
		'id', "AppearancesList",
		'name', "Appearances List",
		'template', true,
		'base_class', "AppearanceWeight",
		'inclusive', true,
		'auto_expand', true,
	}),
	PlaceObj('PropertyDefText', {
		'category', "Appearance",
		'id', "ForcedAppearance",
		'no_edit', true,
		'translate', false,
	}),
	PlaceObj('PropertyDefButtons', {
		'category', "Spawn",
		'id', "SpawnAppearancesButton",
		'name', "",
		'buttons', {
			PlaceObj('PropertyDefPropButton', {
				'Name', "Spawn All NPCs",
				'FuncName', "SpawnAll",
			}),
		},
	}),
	PlaceObj('PropertyDefButtons', {
		'category', "Spawn",
		'id', "SpawnButton",
		'name', "",
		'buttons', {
			PlaceObj('PropertyDefPropButton', {
				'Name', "Spawn Random",
				'FuncName', "Spawn",
			}),
		},
	}),
	PlaceObj('PropertyDefFunc', {
		'category', "Spawn",
		'id', "Spawn",
		'name', "",
		'read_only', true,
		'no_edit', true,
		'params', "self, pos",
		'default', function (self, pos)
			local weighted_list = GetAppearancesListTotalWeight(self)
			local slot = AsyncRand(weighted_list.total_weight)
			local appearance = GetWeightedAppearance(weighted_list, slot)
			
			local spawn_pos =  GetTerrainCursorXY(UIL.GetScreenSize()/2)
			local obj = AppearanceObjectAME:new()
			obj:ApplyAppearance(appearance)
			obj:SetPos(spawn_pos)
			obj:SetGameFlags(const.gofRealTimeAnim)
		end,
	}),
	PlaceObj('PropertyDefFunc', {
		'category', "Spawn",
		'id', "SpawnAll",
		'name', "",
		'read_only', true,
		'no_edit', true,
		'default', function (self)
			local characters = {}
			local widths = {}
			local total_width = 0
			for i, descr in ipairs(self.AppearancesList) do
			  characters[i] = AppearanceObjectAME:new()
			  characters[i]:ApplyAppearance(descr.Preset)
			  local width = characters[i]:GetSize():sizex()
			  widths[i] = width
			  total_width =total_width + width + guim
			end
			
			
			local right = camera.GetRight()
			local lookat = camera.GetEye()
			local spawn_pos =  GetTerrainCursorXY(UIL.GetScreenSize()/2)
			spawn_pos = spawn_pos - SetLen(right, total_width / 2)
			for i, character in ipairs(characters) do
			  character:SetPos(spawn_pos)
			  character:Face(lookat)
			  character:SetGameFlags(const.gofRealTimeAnim)
			  spawn_pos = spawn_pos + SetLen(right,  widths[i] + guim)
			end
		end,
	}),
	PlaceObj('PropertyDefFunc', {
		'id', "GetLogName",
		'name', "",
		'read_only', true,
		'no_edit', true,
		'default', function (self)
			return self:GetDisplayName()
		end,
	}),
	PlaceObj('PropertyDefFunc', {
		'id', "GetLevel",
		'name', "",
		'read_only', true,
		'no_edit', true,
		'params', "self, baseLevel",
		'default', function (self, baseLevel)
			local curXp = self:GetProperty("Experience")
			local addLevel = 0
			if not IsMerc(self) and Game and not baseLevel then
				addLevel = GameDifficulties[Game.game_difficulty]:ResolveValue("unitBonusLevel") or 0
			end
			if not curXp then return self:GetProperty("StartingLevel") + addLevel end
			for i, xp in ipairs(XPTable) do
				if curXp < xp then
					return i - 1 + addLevel
				end
			end
			return #XPTable + addLevel
		end,
	}),
	PlaceObj('PropertyDefPresetIdList', {
		'category', "Equipment",
		'id', "Equipment",
		'template', true,
		'extra_code', "editor_preview = true",
		'preset_class', "LootDef",
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetDisplayName",
		'code', function (self)
			return self.Nick ~= "" and self.Nick or self.Name
		end,
	}),
	PlaceObj('PropertyDefText', {
		'id', "Group",
		'no_edit', true,
	}),
	PlaceObj('PropertyDefNestedList', {
		'category', "General",
		'id', "AdditionalGroups",
		'name', "Additional Groups",
		'template', true,
		'base_class', "AdditionalGroup",
	}),
	PlaceObj('PropertyDefStringList', {
		'id', "additional_groups",
		'arbitrary_value', true,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "ControlledBy",
		'read_only', true,
		'no_edit', true,
		'default', 1,
	}),
	PlaceObj('PropertyDefCombo', {
		'category', "Hiring - Parameters",
		'id', "Tier",
		'name', "Tier",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'default', "Rookie",
		'items', function (self) return PresetGroupCombo("MercTiers", "Default") end,
	}),
	PlaceObj('PropertyDefCombo', {
		'category', "Hiring - Parameters",
		'id', "Specialization",
		'name', "Specialization",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'default', "None",
		'items', function (self) return PresetGroupCombo("MercSpecializations", "Default") end,
	}),
	PlaceObj('PropertyDefChoice', {
		'category', "Voice",
		'id', "pollyvoice",
		'name', "Polly Voice",
		'template', true,
		'default', "Brian",
		'items', function (self) return g_LocPollyActors end,
	}),
	PlaceObj('PropertyDefChoice', {
		'category', "Appearance",
		'id', "species",
		'name', "Species",
		'template', true,
		'default', "Human",
		'items', function (self) return { "Human", "Crocodile", "Hyena", "Lion", "Hen" } end,
	}),
	PlaceObj('PropertyDefChoice', {
		'category', "Appearance",
		'id', "body_type",
		'name', "Body Type",
		'template', true,
		'default', "Human",
		'items', function (self) return { "Human", "Small animal", "Large animal" } end,
	}),
	PlaceObj('PropertyDefChoice', {
		'category', "Appearance",
		'id', "gender",
		'name', "Gender",
		'template', true,
		'default', "N/A",
		'items', function (self) return { "N/A", "Male", "Female" } end,
	}),
	PlaceObj('PropertyDefBool', {
		'category', "Appearance",
		'id', "infected",
		'name', "Infected",
		'template', true,
	}),
	PlaceObj('PropertyDefSet', {
		'category', "Appearance",
		'id', "blocked_spots",
		'name', "Blocked Spots",
		'template', true,
		'items', function (self) return { "Weaponrs", "Weaponls" } end,
	}),
	PlaceObj('PropertyDefText', {
		'category', "General",
		'id', "PersistentSessionId",
		'name', "Persistent Session Id",
		'help', "optional, all units spawned from this template will use the specified session id",
		'template', true,
		'translate', false,
	}),
	PlaceObj('PropertyDefPresetId', {
		'category', "Voice",
		'id', "VoiceResponseId",
		'name', "Voice Response Id",
		'help', "The VoiceResponse preset used be this unit; same as the unit Id by default",
		'template', true,
		'preset_class', "VoiceResponse",
	}),
	PlaceObj('PropertyDefPresetId', {
		'category', "Voice",
		'id', "FallbackMissingVR",
		'name', "FallbackMissingVR",
		'help', "If no vr is found for this unit. Use this fallback unit for the vr. Applies only for Humans.",
		'template', true,
		'preset_class', "UnitDataCompositeDef",
		'default', "VillagerMale",
	}),
	PlaceObj('PropertyDefPresetId', {
		'category', "Appearance",
		'id', "RoamAnimationSet",
		'name', "Roam Animation Set",
		'help', "The VoiceResponse preset used be this unit; same as the unit Id by default",
		'template', true,
		'preset_class', "AnimationSet",
		'preset_group', "AmbientLife",
		'default', "Roam_Default",
	}),
	PlaceObj('PropertyDefText', {
		'category', "General",
		'id', "session_id",
		'no_edit', true,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "combat_damage_taken",
		'help', "persistable damage taken, used for determining when to add Wounded status",
		'no_edit', true,
		'default', 0,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "time_of_death",
		'help', "time of death (satellite time)",
		'no_edit', true,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "randomization_seed",
		'no_edit', true,
		'default', 0,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Hiring - Parameters",
		'id', "DaysUntilOnline",
		'name', "Days Until Online",
		'help', "If the merc is set as offline at the beginning of the campaign through the randomess roll, it will automatically go online this amount of days after campaign start.",
		'template', true,
		'extra_code', "no_edit = function(self) return not IsMerc(self) end",
		'default', 5,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "AddWounds",
		'params', "wounds",
		'code', function (self, wounds)
			wounds = AdjustWoundsToHP(self, wounds or 1)
			if wounds > 0 then
				self:AddStatusEffect("Wounded", wounds)
			end
		end,
	}),
	PlaceObj('PropertyDefFunc', {
		'id', "AccumulateDamageTaken",
		'name', "",
		'read_only', true,
		'no_edit', true,
		'params', "self, amount",
		'default', function (self, amount)
			local Wounded = CharacterEffectDefs.Wounded
			local wounded_add = Wounded:ResolveValue("HpLossToAddStack")
			-- limit damage carried over from the past to the amount required for a single wound only
			self.combat_damage_taken = Min(self.combat_damage_taken, wounded_add)
			self.combat_damage_taken = self.combat_damage_taken + amount
			local threshold = MulDivRound(self:GetInitialMaxHitPoints(), Wounded:ResolveValue("WoundsImmunityThreshold"), 100)
			local stacks = 0
			while self.HitPoints < threshold and self.combat_damage_taken >= wounded_add do
				stacks = stacks + 1
				self.combat_damage_taken = self.combat_damage_taken - wounded_add
			end
			if stacks > 0 then self:AddWounds(stacks) end
		end,
	}),
	PlaceObj('ClassGlobalCodeDef', {
		'comment', "prop_table property to hold signature skill recharge data",
		'code', function ()
			table.insert(UnitProperties.properties, { id = "signature_recharge", editor = "prop_table", default = false, no_edit = true })
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetBaseCrit",
		'params', "weapon",
		'code', function (self, weapon)
			if not self then
				return weapon.CritChance + weapon.CritChanceScaled
			end
			
			return weapon.CritChance + MulDivRound(weapon.CritChanceScaled, self:GetLevel(), 10)
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "Getbase_BaseCrit",
		'params', "weapon",
		'code', function (self, weapon)
			if not self then
				return weapon.base_CritChance + weapon.base_CritChanceScaled
			end
			
			return weapon.base_CritChance + MulDivRound(weapon.base_CritChanceScaled, self:GetLevel(), 10)
		end,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "perkPoints",
		'name', "Perk Points",
		'help', "Avaliable points to spend on unlocking perks.",
		'default', 0,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetPersonalMorale",
		'code', function (self)
			local teamMorale = self.team and self.team.morale or 0
			--modifiers to personal morale for each merc
			local personalMorale = 0
			--reduce morale for at least one disliked merc in team
			local isDisliking = false
			for _, dislikedMerc in ipairs(self.Dislikes) do
				local dislikedIndex = table.find(self.team.units, "session_id", dislikedMerc)
				if dislikedIndex and not self.team.units[dislikedIndex]:IsDead() then
					personalMorale = personalMorale - 1
					isDisliking = true
					break
				end
			end
			--increase morale for no disliked and at least one liked merc
			if not isDisliking then
				for _, likedMerc in ipairs(self.Likes) do
					local likedIndex = table.find(self.team.units, "session_id", likedMerc)
					if likedIndex and not self.team.units[likedIndex]:IsDead()  then
						personalMorale = personalMorale + 1
						break
					end
				end
			end
			--lower morale if below 50% or 3+ wounds (REVERT for psycho perk)
			local isWounded = false
			local idx = self:HasStatusEffect("Wounded")
			if idx and self.StatusEffects[idx].stacks >= 3 then
				isWounded = true
			end
			if self.HitPoints < MulDivRound(self.MaxHitPoints, 50, 100) or isWounded then
				if HasPerk(self, "Psycho") then
					personalMorale = personalMorale + 1
				else
					personalMorale = personalMorale - 1
				end
			end
			--lower morale if liked merc has died recently
			for _, likedMerc in ipairs(self.Likes) do
				local ud = gv_UnitData[likedMerc]
				if ud and ud.HireStatus == "Dead" then
					local deathDay = ud.HiredUntil
					if deathDay + 7 * const.Scale.day > Game.CampaignTime then
						personalMorale = personalMorale - 1
						break
					end
				end
			end
			--lower morale if claustrophobic or zoophobic perk is active
			if self:HasStatusEffect("ZoophobiaChecked") then
				personalMorale = personalMorale - 1
			end
			if self:HasStatusEffect("ClaustrophobiaChecked") then
				personalMorale = personalMorale - 1
			end
			--lower morale if friendly fire
			if self:HasStatusEffect("FriendlyFire") then
				personalMorale = personalMorale - 1
			end
			--lower/increase if proud/guilty effect is on
			if self:HasStatusEffect("Conscience_Guilty") then
				personalMorale = personalMorale - 1
			end
			if self:HasStatusEffect("Conscience_Sinful") then
				personalMorale = personalMorale - 2
			end
			if self:HasStatusEffect("Conscience_Proud") then
				personalMorale = personalMorale + 1
			end
			if self:HasStatusEffect("Conscience_Righteous") then
				personalMorale = personalMorale + 2
			end
			
			return Clamp(personalMorale + teamMorale, -3, 3)
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "HasPassedTimeAfterDeath",
		'params', "givenTime",
		'code', function (self, givenTime)
			if self.time_of_death then
				local deathTimeH = self.time_of_death / const.Scale.h
				local currentTimeH = Game.CampaignTime / const.Scale.h
				if deathTimeH + givenTime <= currentTimeH then
					return true
				end
			end
			return false
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetToughness",
		'code', function (self)
			local toughness = self:GetLevel() * 1000
			local stats = UnitPropertiesStats:GetProperties()
			for _, stat in ipairs(stats) do
				toughness = toughness + self[stat.id]
			end
			return toughness
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "RechargeSignatures",
		'code', function (self)
			self.signature_recharge = {}
			ObjModified(self)
		end,
	}),
})

PlaceObj('ClassDef', {
	DefParentClassList = {
		"PropertyObject",
		"Modifiable",
	},
	DefPropertyTranslation = true,
	group = "Zulu",
	id = "UnitPropertiesStats",
	PlaceObj('PropertyDefNumber', {
		'category', "Stats",
		'id', "Health",
		'name', T(561192724204, --[[ClassDef Zulu UnitPropertiesStats name]] "Health"),
		'help', T(755618869033, --[[ClassDef Zulu UnitPropertiesStats help]] "Represents both the physical well-being of a merc and the amount of damage they can take before becoming downed."),
		'template', true,
		'default', 60,
		'slider', true,
		'min', 0,
		'max', 100,
		'modifiable', true,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Stats",
		'id', "Agility",
		'name', T(427915460935, --[[ClassDef Zulu UnitPropertiesStats name]] "Agility"),
		'help', T(313570226997, --[[ClassDef Zulu UnitPropertiesStats help]] "Measures how well a merc reacts physically to a new situation. Affects the total amount of AP, free movement at start of turn, and how stealthy the merc is."),
		'template', true,
		'default', 60,
		'slider', true,
		'min', 0,
		'max', 100,
		'modifiable', true,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Stats",
		'id', "Dexterity",
		'name', T(460461870476, --[[ClassDef Zulu UnitPropertiesStats name]] "Dexterity"),
		'help', T(485643076124, --[[ClassDef Zulu UnitPropertiesStats help]] "Measures a merc's ability to perform delicate or precise movements correctly. Affects bonus from aiming and Stealth Kill chance."),
		'template', true,
		'default', 60,
		'slider', true,
		'min', 0,
		'max', 100,
		'modifiable', true,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Stats",
		'id', "Strength",
		'name', T(736846833602, --[[ClassDef Zulu UnitPropertiesStats name]] "Strength"),
		'help', T(790754099931, --[[ClassDef Zulu UnitPropertiesStats help]] "Represents muscle and brawn. It's particularly important in Melee combat, affects throwing range and the size of the personal inventory of the character."),
		'template', true,
		'default', 60,
		'slider', true,
		'min', 0,
		'max', 100,
		'modifiable', true,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Stats",
		'id', "Wisdom",
		'name', T(140562214443, --[[ClassDef Zulu UnitPropertiesStats name]] "Wisdom"),
		'help', T(731447408225, --[[ClassDef Zulu UnitPropertiesStats help]] "Affects a merc's ability to learn from experience and training. Affects wilderness survival and the chance to notice hidden items and enemies."),
		'template', true,
		'default', 60,
		'slider', true,
		'min', 0,
		'max', 100,
		'modifiable', true,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Stats",
		'id', "Leadership",
		'name', T(693671613488, --[[ClassDef Zulu UnitPropertiesStats name]] "Leadership"),
		'help', T(396825125419, --[[ClassDef Zulu UnitPropertiesStats help]] "Measures charm, respect and presence. Affects the rate for training militia and other mercs. Affects the chance for getting positive and negative Morale events."),
		'template', true,
		'default', 60,
		'slider', true,
		'min', 0,
		'max', 100,
		'modifiable', true,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Stats",
		'id', "Marksmanship",
		'name', T(616386794188, --[[ClassDef Zulu UnitPropertiesStats name]] "Marksmanship"),
		'help', T(403638137917, --[[ClassDef Zulu UnitPropertiesStats help]] "Reflects a merc's ability to shoot accurately at any given target with a firearm."),
		'template', true,
		'default', 60,
		'slider', true,
		'min', 0,
		'max', 100,
		'modifiable', true,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Stats",
		'id', "Mechanical",
		'name', T(302186486914, --[[ClassDef Zulu UnitPropertiesStats name]] "Mechanical"),
		'help', T(338853681186, --[[ClassDef Zulu UnitPropertiesStats help]] "Rates a merc's ability to repair damaged, worn-out or broken items and equipment. Important for lockpicking, machine handling and hacking electronic devices. Used for detecting and disarming non-explosive traps."),
		'template', true,
		'default', 60,
		'slider', true,
		'min', 0,
		'max', 100,
		'modifiable', true,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Stats",
		'id', "Explosives",
		'name', T(205333258567, --[[ClassDef Zulu UnitPropertiesStats name]] "Explosives"),
		'help', T(767865457232, --[[ClassDef Zulu UnitPropertiesStats help]] "Determines a merc's ability to use grenades and other explosives and affects damage and mishap chance when using thrown items. Used for detecting and disarming explosive traps."),
		'template', true,
		'default', 60,
		'slider', true,
		'min', 0,
		'max', 100,
		'modifiable', true,
	}),
	PlaceObj('PropertyDefNumber', {
		'category', "Stats",
		'id', "Medical",
		'name', T(295773259174, --[[ClassDef Zulu UnitPropertiesStats name]] "Medical"),
		'help', T(249121777425, --[[ClassDef Zulu UnitPropertiesStats help]] "Represents a merc's medical knowledge and ability to heal the wounded."),
		'template', true,
		'default', 60,
		'slider', true,
		'min', 0,
		'max', 100,
		'modifiable', true,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetAttributes",
		'code', function (self)
			local result = self:GetProperties()
			result = table.ifilter(result, function(k, v)
				return v.id == "Health" or
							v.id == "Agility" or
							v.id == "Dexterity" or
							v.id == "Strength" or
							v.id == "Wisdom"
			end)
			return result
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetSkills",
		'code', function (self)
			local result = self:GetProperties()
			result = table.ifilter(result, function(k, v)
				return v.id == "Marksmanship" or
							v.id == "Mechanical" or
							v.id == "Explosives" or
							v.id == "Medical"  or
							v.id == "Leadership"
			end)
			return result
		end,
	}),
})

PlaceObj('ClassDef', {
	group = "Zulu",
	id = "UnitTarget",
	PlaceObj('PropertyDefCombo', {
		'id', "TargetUnit",
		'name', "Target Unit",
		'help', "Target unit for match",
		'items', function (self) return GetTargetUnitCombo() end,
	}),
	PlaceObj('PropertyDefBool', {
		'id', "DisableContextModification",
		'help', "Disables modification of the current context units. Use this option when you don't want to affect the context of following conditions/effects.",
	}),
	PlaceObj('ClassMethodDef', {
		'name', "Match",
		'params', "target, unit, context",
		'code', function (self, target, unit, context)
			if target == "any" then
				return true
			elseif IsKindOf(unit, "Unit") and target== "any merc" then
			 	return unit:IsMerc()
			elseif IsKindOf(unit, "UnitData") and target == "any merc" then
				return IsMerc(UnitDataDefs[unit.class])
			elseif target ==  "player mercs on map" then
				return IsKindOf(unit, "Unit") and unit.team and unit.team.side == "player1"
			elseif (target == "current unit") then
				return  table.find(context and context.target_units or empty_table, unit)
			else
				if IsKindOf(unit, "Unit") then
					if unit:IsInGroup(target) then
						return true
					end
				end
				
				if IsKindOf(unit, "CheeringDummy") then
					local groups = unit.Groups
					if table.find(groups, target) then
						return true
					end
				end
				
				if UnitDataDefs[target] and IsKindOfClasses(unit, "Unit", "UnitData") then
					return target == unit.unitdatadef_id or target == unit.class
				end	
			end
			return false
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "MatchMapUnit",
		'params', "target, unit, context",
		'code', function (self, target, unit, context)
			if target == "any" then
				return true
			elseif target == "any merc" then
				return unit:IsMerc()
			elseif target == "player mercs on map" then
				return unit.team and unit.team.side == "player1"
			elseif target == "current unit" then
				return  table.find(context and context.target_units or empty_table, unit)
			else
				if unit:IsInGroup(target) then
					return true
				end
				
				if UnitDataDefs[target] then
					return target == unit.unitdatadef_id or target == unit.class
				end	
			end
			
			return false
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "MatchMapUnits",
		'params', "obj, context",
		'code', function (self, obj, context)
			local triggered
			local new_units = {}
			local units = false
			local unitsAreClassUnit = true
			if self.TargetUnit == "player mercs on map" then
				local team = GetCampaignPlayerTeam()
				if team then
					units = team.units
				end
			end
			
			if context and not units then
				if self.TargetUnit == "current unit" then
					units = context.target_units
				elseif context.is_sector_unit then
					if not obj then return false end
					units = {obj}
				end
				unitsAreClassUnit = false
			end
			
			-- performance optimization
			local matchFunc = unitsAreClassUnit and self.MatchMapUnit or self.Match
			
			for _, unit in ipairs(units or g_Units) do
				assert(not unitsAreClassUnit or IsKindOf(unit, "Unit"))
				if matchFunc(self, self.TargetUnit, unit, context) and self:UnitCheck(unit, obj, context) then
					if not self.Negate then
						table.insert_unique(new_units, unit)
					end
					triggered = true
				elseif self.Negate then
					table.insert_unique(new_units, unit)
				end
			end
			if not self.DisableContextModification and type(context) == "table" then
				context.target_units  =  new_units
			end
			return triggered
		end,
	}),
	PlaceObj('ClassMethodDef', {
		'name', "UnitCheck",
		'params', "unit, obj,context",
		'code', function (self, unit, obj,context)
			return true
		end,
	}),
})

PlaceObj('ClassDef', {
	Comment = "Used to define multiple unit_types to choose randomly from",
	group = "Zulu",
	id = "UnitTypeListWithWeights",
	PlaceObj('PropertyDefPresetId', {
		'id', "unitType",
		'name', "Unit Type",
		'help', "Type of the unit",
		'preset_class', "UnitDataCompositeDef",
		'extra_item', "empty",
		'default', "",
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "spawnWeight",
		'name', "Spawn Weight",
		'help', "The weight to assign for the given unit that determines the chance of choosing it",
		'default', 100,
		'min', 1,
		'max', 100,
	}),
	PlaceObj('PropertyDefNestedList', {
		'id', "conditions",
		'name', "Conditions",
		'help', "The unit is only added to the weight pool if the conditions pass.",
		'base_class', "Condition",
	}),
	PlaceObj('ClassMethodDef', {
		'name', "GetEditorView",
		'code', function (self)
			return tostring(self.unitType)
		end,
	}),
	PlaceObj('PropertyDefCombo', {
		'id', "visualOverride",
		'name', "Override Visuals",
		'items', function (self) return PresetsCombo("UnitDataCompositeDef") end,
	}),
	PlaceObj('PropertyDefText', {
		'id', "nameOverride",
		'name', "Override Name",
	}),
})

PlaceObj('PresetDef', {
	DefParentClassList = {
		"ListPreset",
	},
	group = "Zulu",
	id = "WeaponColor",
	PlaceObj('PropertyDefText', {
		'id', "name",
	}),
	PlaceObj('PropertyDefText', {
		'id', "Slot",
		'no_edit', true,
		'default', T(898895049831, --[[PresetDef WeaponColor default]] "Color"),
	}),
	PlaceObj('PropertyDefText', {
		'id', "Description",
	}),
	PlaceObj('PropertyDefColor', {
		'id', "color",
		'default', RGBA(255, 255, 255, 255),
	}),
	PlaceObj('PropertyDefRange', {
		'id', "Roughness",
		'name', "Roughness",
		'min', -128,
		'max', 127,
	}),
	PlaceObj('PropertyDefRange', {
		'id', "Metallic",
		'name', "Metallic",
		'min', -256,
		'max', 254,
	}),
	PlaceObj('PropertyDefNumber', {
		'id', "Cost",
		'name', "Cost (Parts)",
		'help', "The cost of the upgrade in parts",
		'default', 0,
	}),
})

